<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NewsBoard</title>
  <link rel="icon" href="data:,">

  <style>
    :root{
      --bg:#F7F8FA;
      --surface:#FFFFFF;
      --card:#FFFFFF;
      --text:#111827;
      --muted:#6B7280;
      --border:#E5E7EB;
      --line:var(--border);
      --line-strong:#D1D5DB;
      --accent:#2563EB;
      --good:#22C55E;
      --danger:#EF4444;
      --highlight-bg:#FEF3C7;
      --highlight-text:#92400E;
      --highlight-border:#F59E0B;
      --shadow: 0 1px 2px rgba(17,24,39,0.06);
      --radius: 10px;
      --maxw: 1100px;

      --blue:var(--accent);
      --blue2:#1D4ED8;

      --ok:var(--good);
      --bad:var(--danger);
      --warn:var(--highlight-border);

      --chip:#F9FAFB;
      --chipText:#374151;

      --font-sans: "Avenir Next", "Segoe UI", "Helvetica Neue", Arial, sans-serif;
      --font-serif: "Iowan Old Style", "Palatino Linotype", Palatino, "Book Antiqua", Georgia, serif;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: var(--font-sans);
      background: var(--bg);
      color: var(--text);
    }

    header{
      position:sticky;
      top:0;
      z-index:20;
      background: rgba(247,248,250,.96);
      border-bottom: 1px solid var(--line);
    }

    .topbar{
      max-width:var(--maxw);
      margin:0 auto;
      padding:8px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    .brand{ display:flex; flex-direction:column; gap:2px; min-width: 220px; }
    .brand .title{ font-weight:800; letter-spacing:.2px; font-size:16px; line-height:1.1; }
    .brand .sub{ color:var(--muted); font-size:12px; }

    .controls{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end; }
    .statusInline{
      font-size:11px;
      color:var(--muted);
      min-width:84px;
      text-align:right;
    }

    .btn{
      border:1px solid var(--line);
      background: var(--card);
      color: var(--text);
      font-size:13px;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      user-select:none;
      box-shadow: none;
    }
    .btn:hover{ border-color: rgba(37,99,235,.45); color:var(--accent); }
    .btn:disabled{ opacity:.55; cursor:not-allowed; }

    main{ max-width:var(--maxw); margin:0 auto; padding:14px 16px 26px; }

    .viewTabs{
      display:flex;
      gap:8px;
      margin-bottom:10px;
      border-bottom:1px solid var(--line);
      padding-bottom:8px;
    }
    .tabBtn{
      border:1px solid transparent;
      background:transparent;
      color:var(--muted);
      padding:8px 10px;
      border-radius:8px;
      font-size:13px;
      font-weight:700;
      letter-spacing:.2px;
      cursor:pointer;
    }
    .tabBtn.active{
      color:var(--accent);
      background:#EFF6FF;
      border-color:var(--accent);
    }

    .legend{
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      gap:8px;
      margin-bottom:10px;
      color:var(--muted);
      font-size:12px;
    }
    .legendInline{ display:flex; align-items:center; gap:8px; }
    .legendToggle{
      border:1px solid var(--line);
      background:var(--surface);
      color:var(--muted);
      border-radius:999px;
      width:20px;
      height:20px;
      line-height:18px;
      text-align:center;
      padding:0;
      cursor:pointer;
      font-size:12px;
      font-weight:700;
    }
    .legendMore{ display:none; width:100%; gap:8px; flex-wrap:wrap; }
    .legendMore.open{ display:flex; }
    .legendPill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      border:1px solid var(--line);
      background:var(--surface);
      border-radius:999px;
      padding:4px 9px;
    }
    .legendNote{ color:var(--muted); }

    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 900px){
      .grid{ grid-template-columns: 1fr; }
      .brand{ min-width: unset; }
    }

    /* Change indicators near headlines */
    .change-indicator{
      display:inline-block;
      width:8px;
      height:8px;
      border-radius:50%;
      margin-left:8px;
      vertical-align:middle;
      opacity:0.8;
      transition:opacity 0.4s ease;
    }
    .change-indicator.new-url{ background:var(--ok); }
    .change-indicator.new-headline{ background:var(--blue); }
    .change-indicator.stale{ background:var(--line-strong); }

    .card{
      background: var(--card);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      --enter-x: 0px;
      --enter-y: 18px;
      --enter-r: 0deg;
      --enter-delay: 0ms;
    }
    @media (prefers-reduced-motion: no-preference){
      .card.card-enter{
        opacity:0;
        transform: translate3d(var(--enter-x), var(--enter-y), 0) rotate(var(--enter-r)) scale(0.985);
        filter: blur(1.5px);
        will-change: transform, opacity, filter;
      }
      .card.card-enter.card-settle{
        opacity:1;
        transform: translate3d(0, 0, 0) rotate(0deg) scale(1);
        filter: none;
        transition:
          opacity 300ms ease-out,
          transform 520ms cubic-bezier(.2,.9,.2,1),
          filter 420ms ease-out;
        transition-delay: var(--enter-delay);
      }
    }

    .cardHead{
      padding:10px 12px 9px;
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
      border-bottom:1px solid var(--line);
      background: var(--surface);
    }

    .srcTitle{ display:flex; align-items:center; gap:6px; min-width:0; }
    .srcTitle .srcMeta{ flex:1 1 auto; }
    .copyIconBtn{
      border:1px solid var(--line);
      background:var(--card);
      color:var(--muted);
      border-radius:6px;
      width:24px;
      height:24px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-size:12px;
      line-height:1;
      padding:0;
      cursor:pointer;
      flex:0 0 auto;
    }
    .copyIconBtn:hover{ border-color: rgba(37,99,235,.45); color:var(--blue2); }

    .srcMeta{ display:flex; flex-direction:column; gap:2px; min-width:0; }
    .srcMetaInline{
      flex-direction:row;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .srcName{ font-weight:700; font-size:14px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .srcNameLink{ color:inherit; text-decoration:none; }
    .srcNameLink:hover{ color:var(--blue); text-decoration:underline; }
    .srcTime{ font-size:13px; color: var(--muted); white-space:nowrap; }

    .rightMeta{ display:flex; flex-direction:column; align-items:flex-end; gap:2px; text-align:right; }

    .tiny{ font-size:12px; color: var(--muted); }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    .cardBody{
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:stretch;
    }

    .headlineWrap{ width:100%; min-width:0; flex:1 1 auto; display:flex; flex-direction:column; gap:7px; }

    .headline{ font-size:18px; line-height:1.26; font-weight:700; margin:0; font-family: var(--font-serif); }
    .headline a{ color: var(--text); text-decoration:none; }
    .headline a:hover{ color: var(--blue); text-decoration: underline; }
    .liveBlogTag{
      color:#b00020;
      font-size:11px;
      font-weight:800;
      letter-spacing:.05em;
      text-transform:uppercase;
      line-height:1;
    }
    .videoTag{
      color:var(--blue);
      font-size:11px;
      font-weight:800;
      letter-spacing:.05em;
      text-transform:uppercase;
      line-height:1;
    }
    .breakingNewsTag{
      color:#b00020;
      font-size:12px;
      font-weight:900;
      letter-spacing:.03em;
      text-transform:uppercase;
      line-height:1;
    }

    .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .changeRow{ display:flex; align-items:center; gap:0; font-size:12px; color:var(--muted); }
    .cardActions{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      flex-wrap:wrap;
    }
    .changeDot{
      width:8px;
      height:8px;
      border-radius:50%;
      display:inline-block;
      flex:0 0 auto;
    }
    .changeDot.url{ background:var(--ok); }
    .changeDot.headline{ background:var(--blue); }
    .changeDot.stale{ background:var(--line-strong); }
    .changeDot.none{ background:var(--line-strong); }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:6px 10px;
      border-radius:999px;
      background: var(--chip);
      border:1px solid var(--line);
      color: var(--chipText);
      font-size:12px;
    }
    .linkbtn{
      border:1px solid var(--line);
      background: var(--card);
      color: var(--text);
      font-size:12px;
      padding:6px 10px;
      border-radius:8px;
      cursor:pointer;
    }
    .linkbtn:hover{ border-color: rgba(37,99,235,.45); color: var(--blue2); }
    .shotTile{
      display:flex;
      flex-direction:column;
      gap:6px;
      padding:8px;
      border:1px solid var(--line);
      border-radius:12px;
      background:var(--card);
      cursor:pointer;
      text-align:left;
    }
    .shotFrame{
      width:100%;
      max-width:972px;
      margin:0 auto;
      touch-action: pan-y;
    }
    .shotRailControls{
      display:flex;
      flex-direction:column;
      align-items:stretch;
      gap:8px;
    }
    .shotRailScrubber{
      width:100%;
      min-width:120px;
      accent-color: var(--blue);
    }

    .toast{
      position:fixed;
      left:50%;
      bottom:18px;
      transform: translateX(-50%);
      background:#202124;
      color:#fff;
      padding:10px 12px;
      border-radius:999px;
      font-size:12px;
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease;
      box-shadow: 0 6px 24px rgba(0,0,0,.22);
      z-index:999;
    }
    .toast.show{ opacity: 1; }

    .siteFooter{
      margin-top:20px;
      border-top:1px solid var(--line);
      background:var(--surface);
    }
    .siteFooterInner{
      max-width:var(--maxw);
      margin:0 auto;
      padding:12px 16px 16px;
      color:var(--muted);
      font-size:12px;
      line-height:1.5;
    }
    .siteFooter a{
      color:var(--blue);
      text-decoration:none;
    }
    .siteFooter a:hover{ text-decoration:underline; }

    .drawerOverlay{
      position:fixed;
      inset:0;
      background: rgba(32,33,36,.35);
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease;
      z-index:60;
    }
    .drawerOverlay.show{ opacity:1; pointer-events:auto; }

    .drawer{
      position:fixed;
      top:0;
      right:0;
      height:100vh;
      width:min(520px, calc(100vw - 48px));
      background: var(--bg);
      border-left:1px solid var(--line);
      box-shadow: -3px 0 16px rgba(30,36,43,.08);
      transform: translateX(100%);
      transition: transform .22s ease;
      z-index:70;
      display:flex;
      flex-direction:column;
    }
    #drawer-data{
      left:50%;
      right:auto;
      top:50%;
      bottom:auto;
      width:min(920px, calc(100vw - 64px));
      height:min(86vh, 840px);
      max-height:min(86vh, 840px);
      transform:translate(-50%, calc(100% + 24px));
      border:1px solid var(--line);
      border-radius:14px;
      box-shadow:0 10px 28px rgba(30,36,43,.2);
    }
    #drawer-source-data{
      left:50%;
      right:auto;
      top:50%;
      bottom:auto;
      width:min(1242px, calc(100vw - 32px));
      height:min(90vh, 920px);
      max-height:min(90vh, 920px);
      transform:translate(-50%, calc(100% + 24px));
      border:1px solid var(--line);
      border-radius:14px;
      box-shadow:0 10px 28px rgba(30,36,43,.2);
    }
    #drawer-data.open,
    #drawer-source-data.open{
      transform:translate(-50%, -50%);
    }
    .detailsTabs{
      display:flex;
      gap:6px;
      margin-top:8px;
    }
    .detailsTab{
      border:1px solid var(--line);
      background:var(--surface);
      color:var(--muted);
      border-radius:999px;
      padding:6px 10px;
      font-size:12px;
      font-weight:700;
      cursor:pointer;
    }
    .detailsTab.active{
      color:var(--text);
      border-color:var(--line-strong);
      background:#fff;
    }
    .statsGrid{
      display:grid;
      grid-template-columns:repeat(2,minmax(0,1fr));
      gap:8px;
      margin-bottom:10px;
    }
    .statCard{
      border:1px solid var(--line);
      border-radius:10px;
      background:#fff;
      padding:8px;
    }
    .statLabel{ font-size:11px; color:var(--muted); }
    .statValue{ font-size:17px; font-weight:800; margin-top:2px; }
    .chartCard{
      border:1px solid var(--line);
      border-radius:10px;
      background:#fff;
      padding:8px;
      margin-bottom:8px;
    }
    .chartTitle{ font-size:12px; color:var(--muted); margin-bottom:6px; }
    .chartCanvas{ width:100%; height:120px; display:block; }
    .inlineEmpty{
      font-size:12px;
      color:var(--muted);
      border:1px dashed var(--line);
      border-radius:10px;
      padding:10px;
      background:var(--surface);
    }
    .drawer.open{ transform: translateX(0); }

    .drawerHead{
      padding:12px 14px;
      background: rgba(247,248,250,.96);
      border-bottom:1px solid var(--line);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .drawerTitle{ font-weight:800; letter-spacing:.2px; }
    .drawerBody{ padding:12px; overflow:auto; }

    .historyList{ display:flex; flex-direction:column; gap:12px; }
    .historySection{ display:flex; flex-direction:column; gap:10px; }
    .historySectionTitle{ font-size:12px; font-weight:800; color:var(--muted); letter-spacing:.3px; text-transform:uppercase; }
    .latestList{ display:flex; flex-direction:column; gap:8px; }
    .latestItem{
      border:1px solid var(--line);
      border-radius: 12px;
      background: var(--card);
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      gap:0;
    }
    .latestItem.isClickable{ cursor:pointer; }
    .latestMetaRow{
      padding:10px 12px 9px;
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
      border-bottom:1px solid var(--line);
      background:#fff;
    }
    .latestBody{ padding:12px; display:flex; gap:12px; align-items:flex-start; }
    .latestMain{ min-width:0; flex:1 1 auto; display:flex; flex-direction:column; gap:8px; }
    .latestTitle{ font-size:16px; line-height:1.3; font-weight:700; margin:0; font-family: var(--font-serif); }
    .latestTitle a{ color: var(--text); text-decoration:none; }
    .latestTitle a:hover{ color: var(--blue); text-decoration: underline; }
    .aboutCard{
      border:1px solid var(--line);
      border-radius:12px;
      background:var(--card);
      box-shadow:var(--shadow);
      padding:12px;
    }
    .aboutTitle{
      margin:0 0 8px 0;
      font-size:14px;
      font-weight:800;
      color:var(--text);
      letter-spacing:.2px;
    }
    .aboutText{
      margin:0;
      font-size:13px;
      line-height:1.5;
      color:var(--muted);
    }

    .hItem{ border:1px solid var(--line); border-radius: 12px; background: var(--card); box-shadow: var(--shadow); overflow:hidden; }
    .hHead{ padding:10px 12px 9px; display:flex; justify-content:space-between; align-items:flex-start; gap:12px; border-bottom:1px solid var(--line); background:#fff; }
    .hBody{ padding:12px; display:flex; gap:12px; align-items:flex-start; }
    .hMain{ min-width:0; flex:1 1 auto; display:flex; flex-direction:column; gap:8px; }
    .hTitle{ font-size:16px; line-height:1.25; font-weight:700; margin:0; font-family: var(--font-serif); }
    .dataTable{
      width:100%;
      border-collapse:collapse;
      font-size:12px;
      background:var(--card);
      border:1px solid var(--line);
      border-radius:10px;
      overflow:hidden;
    }
    .dataTable th,
    .dataTable td{
      padding:8px 10px;
      border-bottom:1px solid var(--line);
      text-align:left;
      vertical-align:top;
    }
    .dataTable th{
      background:var(--surface);
      font-weight:700;
      color:var(--muted);
      white-space:nowrap;
    }
    .dataTable tr:last-child td{ border-bottom:0; }
    .dataPublisherCell{ min-width:130px; }
    .dataSortBtn{
      border:0;
      background:transparent;
      color:inherit;
      font:inherit;
      font-weight:inherit;
      padding:0;
      cursor:pointer;
    }
    .dataSortBtn:hover{ color:var(--blue2); }
    .dataSortBtn .sortArrow{ color:var(--muted); margin-left:4px; }
    .clusterControls{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-bottom:12px;
      padding:10px;
      border:1px solid var(--line);
      border-radius:10px;
      background:var(--card);
    }
    .clusterRow{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .clusterChipRow{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap:6px;
      border:1px solid var(--line);
      background:var(--card);
      border-radius:999px;
      padding:5px 9px;
      font-size:12px;
      color:var(--chipText);
    }
    .chipLabel{
      border:0;
      background:transparent;
      padding:0;
      margin:0;
      cursor:pointer;
      color:inherit;
      font:inherit;
    }
    .chipLabel:hover{ color:var(--blue2); }
    .chipAction{
      border:0;
      background:transparent;
      color:var(--muted);
      cursor:pointer;
      font-size:11px;
      line-height:1;
      padding:0 2px;
    }
    .chipAction:hover{ color:var(--blue2); }
    #cluster-groups{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .clusterGroup{
      border:0;
      border-radius:0;
      background:transparent;
      padding:0;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .clusterHeader{
      display:flex;
      align-items:baseline;
      gap:8px;
      padding:0 2px;
    }
    .clusterHeader h1{
      margin:0;
      font-size:18px;
      font-family:var(--font-serif);
    }
    .clusterGroup .card{ cursor:grab; }
    .clusterGroup .card.dragging{
      opacity:.55;
      cursor:grabbing;
    }
    .labsSection{
      border:1px solid var(--line);
      border-radius:var(--radius);
      background:var(--surface);
      padding:12px;
      margin-bottom:12px;
    }
    .labsHeader{
      margin-bottom:10px;
      padding-bottom:8px;
      border-bottom:1px solid var(--line);
    }
    .labsHeader h2{
      margin:0;
      font-size:19px;
      font-family:var(--font-serif);
    }
    .labsHelp{
      margin-top:4px;
      font-size:12px;
      color:var(--muted);
    }
    .emptyState{
      border:1px dashed var(--line-strong);
      border-radius:var(--radius);
      background:var(--surface);
      color:var(--muted);
      padding:20px 14px;
      font-size:13px;
      text-align:center;
    }

    .deepDive{
      background:var(--surface);
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:14px;
    }
    .deepTop{
      display:flex;
      justify-content:space-between;
      align-items:flex-end;
      gap:12px;
      flex-wrap:wrap;
      margin-bottom:12px;
      border-bottom:1px solid var(--line);
      padding-bottom:10px;
    }
    .deepTitle{
      font-size:22px;
      line-height:1.1;
      margin:0;
      font-family:var(--font-serif);
    }
    .deepMeta{ font-size:12px; color:var(--muted); }
    .deepSection{ margin-top:12px; }
    .deepSectionTitle{
      margin:0 0 8px;
      font-size:11px;
      color:var(--muted);
      letter-spacing:.4px;
      text-transform:uppercase;
      font-weight:800;
    }
    .top10List, .deepEvents{
      list-style:none;
      margin:0;
      padding:0;
      display:flex;
      flex-direction:column;
      gap:0;
    }
    .top10Row, .deepEvent{
      border-bottom:1px solid var(--line);
      padding:10px 0;
      display:flex;
      gap:10px;
      align-items:flex-start;
    }
    .top10Meta{
      margin-top:6px;
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      align-items:center;
    }
    .metric{
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .statLabel{
      font-size:10px;
      font-weight:800;
      color:var(--muted);
      letter-spacing:.25px;
      text-transform:uppercase;
    }
    .statBtn{
      border:1px solid var(--line);
      background:var(--chip);
      color:var(--chipText);
      border-radius:999px;
      font-size:11px;
      font-weight:700;
      padding:4px 8px;
      line-height:1;
    }
    .statBtn.isTop10{
      border-color: rgba(23, 92, 211, .45);
      background: linear-gradient(90deg, rgba(23,92,211,.18), rgba(23,92,211,.03));
      color:#1249ab;
    }
    .statBtn.isNo1{
      border-color: rgba(30, 142, 62, .55);
      background: linear-gradient(90deg, rgba(30,142,62,.16), rgba(30,142,62,.03));
      color:#1e8e3e;
    }
    .statBtn.isPrev{
      border-color: rgba(200, 108, 0, .42);
      color:#8f4d00;
      background: linear-gradient(90deg, rgba(200,108,0,.22), rgba(255,255,255,.85));
    }
    .statBtn.isPrev.down{
      background: linear-gradient(90deg, rgba(255,255,255,.88), rgba(200,108,0,.18));
    }
    .relatedWrap{
      margin-top:8px;
      padding-top:8px;
    }
    .relatedToggle{
      border:1px solid var(--line);
      background:var(--surface);
      color:var(--muted);
      border-radius:8px;
      font-size:11px;
      font-weight:700;
      padding:4px 8px;
      cursor:pointer;
    }
    .relatedPanel{
      max-height:0;
      overflow:hidden;
      opacity:0;
      transform: translateY(8px);
      transition: max-height 220ms ease, opacity 180ms ease, transform 220ms ease;
    }
    .relatedPanel.open{
      max-height:min(55vh, 460px);
      overflow:auto;
      opacity:1;
      transform: translateY(0);
      margin-top:8px;
    }
    .relatedList{
      margin:0;
      padding:0;
      list-style:none;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .relatedItem{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      border:1px solid var(--line);
      border-radius:8px;
      padding:6px 8px;
      background:var(--surface);
    }
    .relatedLink{
      color:var(--text);
      font-size:12px;
      text-decoration:none;
      min-width:0;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .relatedLink:hover{ color:var(--blue); text-decoration:underline; }
    .headlineDiff{
      margin-top:8px;
      border-radius:8px;
      padding:8px;
      background:var(--surface);
      font-size:12px;
      line-height:1.35;
    }
    .headlineDiffMeta{
      color:var(--muted);
      font-size:11px;
      margin-bottom:6px;
    }
    .diffDel{
      color:var(--danger);
      text-decoration:line-through;
      text-decoration-thickness:2px;
    }
    .diffAdd{
      color:var(--highlight-text);
      background:var(--highlight-bg);
      border:1px solid var(--highlight-border);
      border-radius:3px;
      padding:0 1px;
    }
    .deepRunRail{
      display:flex;
      flex-direction:column;
      gap:6px;
      align-items:stretch;
      padding:4px 2px 8px;
      border-bottom:1px solid var(--line);
    }
    .deepRunBtn{
      border:1px solid var(--line);
      background:var(--surface);
      color:var(--muted);
      border-radius:8px;
      font-size:11px;
      font-weight:700;
      padding:6px 8px;
      white-space:nowrap;
      cursor:pointer;
    }
    .deepRunBtn.active{
      color:var(--text);
      border-color:var(--line-strong);
      background:var(--chip);
    }
    .snapshotStamp{
      min-width:0;
      text-align:left;
      font-size:12px;
      color:var(--text);
      font-weight:700;
    }
    .snapshotNav{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:8px;
    }
    .snapshotNav .linkbtn{
      min-width:34px;
      padding:6px 10px;
      font-weight:700;
    }
    .headlineNew{
      font-weight:700;
      font-size:13px;
      color:var(--text);
      margin-bottom:4px;
    }
    .top10Rank{
      width:28px;
      flex:0 0 28px;
      font-size:12px;
      font-weight:800;
      color:var(--muted);
    }
    .top10Link{
      font-family:var(--font-serif);
      color:var(--text);
      text-decoration:none;
      font-size:16px;
    }
    .top10Link:hover{ color:var(--blue); text-decoration:underline; }
    .deepStamp{ font-size:12px; color:var(--muted); }
    .eventBadge{
      display:inline-flex;
      border:1px solid var(--line);
      border-radius:999px;
      padding:2px 7px;
      font-size:10px;
      font-weight:800;
      letter-spacing:.3px;
      background:var(--chip);
      color:var(--chipText);
      min-width:52px;
      justify-content:center;
      margin-right:6px;
    }
    .deepEventBody{ min-width:0; }
    .deepEventMain{ font-size:14px; line-height:1.3; font-family:var(--font-serif); }
    .deepEventMeta{ font-size:11px; color:var(--muted); margin-top:2px; }
    .hTitle a{ color: var(--text); text-decoration:none; }
    .hTitle a:hover{ color: var(--blue); text-decoration: underline; }

    @media (max-width: 520px){
      .shotFrame{ max-width: 100%; }
      .shotRailControls .linkbtn{
        padding:6px 8px;
        min-width:38px;
      }
    }
    @media (max-width: 700px){
      #drawer-data,
      #drawer-source-data{
        top:auto;
        bottom:0;
        height:auto;
        max-height:82vh;
        width:100vw;
        transform:translate(-50%, 100%);
        border-radius:14px 14px 0 0;
        border-left:1px solid var(--line);
        border-right:1px solid var(--line);
        border-bottom:none;
        box-shadow:-3px 0 16px rgba(30,36,43,.08);
      }
      #drawer-data.open,
      #drawer-source-data.open{
        transform:translate(-50%, 0);
      }
    }
    @media (max-width: 430px){
      .topbar{
        padding:10px 10px;
        align-items:flex-start;
        flex-direction:column;
        gap:8px;
      }
      .controls{
        width:100%;
        justify-content:flex-start;
      }
      .btn{
        padding:7px 10px;
        font-size:11px;
      }
      main{
        padding:10px 10px 20px;
      }
      .cardHead{
        padding:9px 10px 8px;
      }
      .cardBody{
        padding:10px;
      }
      .drawer{ width:100vw; }
      .drawerBody{
        padding:10px;
      }
      .shotRailControls{
        gap:6px;
      }
    }
    
  </style>
</head>
<body>
  <header>
    <div class="topbar">
      <div class="brand">
        <div class="title">NewsBoard</div>
        <div class="sub" id="subline">Top story tracker</div>
      </div>

      <div class="controls">
        <button id="btn-reload" class="btn" type="button">Refresh</button>
        <button id="btn-menu" class="btn" type="button" aria-label="Open menu">About</button>
        <div id="refresh-indicator" class="statusInline" aria-live="polite"></div>
        <button id="btn-run" class="btn" type="button" style="display:none">Run scrape (local)</button>
      </div>
    </div>
  </header>

  <main>
    <div class="viewTabs" role="tablist" aria-label="Views">
      <button id="tab-overview" class="tabBtn active" type="button" role="tab" aria-selected="true">Overview</button>
      <button id="tab-data" class="tabBtn" type="button" role="tab" aria-selected="false">Data</button>
      <button id="tab-playxplay" class="tabBtn" type="button" role="tab" aria-selected="false">Play x Play</button>
      <button id="tab-labs" class="tabBtn" type="button" role="tab" aria-selected="false">Labs</button>
    </div>
    <div id="legend" class="legend">
      <div class="legendInline">
        <span class="legendNote">Change dots track URL vs headline movement.</span>
        <button id="legend-toggle" class="legendToggle" type="button" aria-expanded="false" aria-label="Legend details">i</button>
      </div>
      <div id="legend-more" class="legendMore">
        <span class="legendPill"><span class="change-indicator new-url"></span> Green dot = URL changed (new top story)</span>
        <span class="legendPill"><span class="change-indicator new-headline"></span> Blue dot = headline changed (same URL)</span>
        <span class="legendPill"><span class="change-indicator stale"></span> Gray dot = stale (no change in 2h)</span>
        <span class="legendNote">First seen shows how long the current top story URL has been in the #1 slot.</span>
      </div>
    </div>

    <section id="view-overview">
      <div class="grid" id="cards-grid"></div>
    </section>

    <section id="view-playxplay" style="display:none">
      <section class="labsSection">
        <div class="labsHeader">
          <h2>Play x Play</h2>
          <div class="labsHelp">Live sequence of publisher top-story updates.</div>
        </div>
        <div id="playxplay-status" class="tiny" style="margin-bottom:8px;color:var(--muted)"></div>
        <div class="historyList" id="playxplay-history"></div>
      </section>
    </section>

    <section id="view-labs" style="display:none">
      <section class="labsSection">
        <div class="labsHeader">
          <h2>Story Clusters</h2>
          <div class="labsHelp">Group top stories by emergent themes and adjust active tags.</div>
        </div>
        <div class="clusterControls">
          <div class="clusterRow">
            <div class="tiny">Active clusters</div>
            <div id="cluster-active" class="clusterChipRow"></div>
          </div>
          <div class="clusterRow">
            <div class="tiny">Suggested clusters</div>
            <div id="cluster-suggestions" class="clusterChipRow"></div>
          </div>
        </div>
        <div id="cluster-groups"></div>
      </section>

      <section class="labsSection">
        <div class="labsHeader">
          <h2>Timeline</h2>
          <div class="labsHelp">Inspect screenshot snapshots and Top 10 ranking movement.</div>
        </div>
        <div class="deepDive">
          <div class="deepTop">
            <div>
              <h2 class="deepTitle">ABC News</h2>
            </div>
            <div class="row">
              <label class="tiny" for="deep-window">Change log window</label>
              <select id="deep-window" class="linkbtn">
                <option value="6">6h</option>
                <option value="24" selected>24h</option>
                <option value="168">7d</option>
              </select>
            </div>
          </div>

          <div class="deepSection">
            <h3 class="deepSectionTitle">Snapshots</h3>
            <div id="deep-run-rail" class="deepRunRail"></div>
          </div>

          <div class="deepSection">
            <h3 class="deepSectionTitle">Top 10 Details</h3>
            <div id="deep-latest-time" class="deepStamp">Observed: —</div>
            <div id="deep-latest-error" class="tiny" style="margin-top:6px"></div>
            <ol id="deep-top10-list" class="top10List"></ol>
          </div>
        </div>
      </section>
    </section>

  </main>

  <footer class="siteFooter">
    <div class="siteFooterInner">
      This project is for research purposes only and is not affiliated with any organization.
      Comments or questions? Email Matt Wilhalme at <a href="mailto:mwilhalme@gmail.com">mwilhalme@gmail.com</a>.
    </div>
  </footer>

  <div class="drawerOverlay" id="drawer-overlay"></div>
  <aside class="drawer" id="drawer-history" aria-hidden="true">
    <div class="drawerHead">
      <div>
        <div class="drawerTitle">History</div>
      </div>
      <div class="row">
        <label class="tiny" for="history-window">Window</label>
        <select id="history-window" class="linkbtn">
          <option value="6">6h</option>
          <option value="24" selected>24h</option>
          <option value="168">7d</option>
        </select>
      </div>
      <button id="btn-history-close" class="btn" type="button">Close</button>
    </div>
    <div class="drawerBody">
      <div class="historyList" id="history"></div>
    </div>
  </aside>

  <aside class="drawer" id="drawer-data" aria-hidden="true">
    <div class="drawerHead">
      <div>
        <div class="drawerTitle">Data</div>
      </div>
      <div class="row">
        <label class="tiny" for="data-window">Window</label>
        <select id="data-window" class="linkbtn">
          <option value="6">6h</option>
          <option value="24" selected>24h</option>
          <option value="168">7d</option>
        </select>
      </div>
      <button id="btn-data-close" class="btn" type="button">Close</button>
    </div>
    <div class="drawerBody">
      <div id="data"></div>
    </div>
  </aside>

  <aside class="drawer" id="drawer-source-data" aria-hidden="true">
    <div class="drawerHead">
      <div>
        <div class="drawerTitle" id="source-data-title">Details</div>
        <div class="tiny" id="source-data-range">—</div>
        <div class="detailsTabs" role="tablist" aria-label="Details tabs">
          <button id="details-tab-changes" class="detailsTab active" type="button" role="tab" aria-selected="true">Changes</button>
          <button id="details-tab-data" class="detailsTab" type="button" role="tab" aria-selected="false">Data</button>
          <button id="details-tab-shots" class="detailsTab" type="button" role="tab" aria-selected="false">Screenshots</button>
        </div>
      </div>
      <div class="row">
        <label class="tiny" for="source-data-window">Window</label>
        <select id="source-data-window" class="linkbtn">
          <option value="6">6h</option>
          <option value="24" selected>24h</option>
          <option value="168">7d</option>
        </select>
      </div>
      <button id="btn-source-data-close" class="btn" type="button">Close</button>
    </div>
    <div class="drawerBody">
      <div id="source-data"></div>
    </div>
  </aside>

  <aside class="drawer" id="drawer-menu" aria-hidden="true">
    <div class="drawerHead">
      <div>
        <div class="drawerTitle">Menu</div>
        <div class="tiny">Navigation</div>
      </div>
      <button id="btn-menu-close" class="btn" type="button">Close</button>
    </div>
    <div class="drawerBody">
      <div class="historyList">
        <div class="aboutCard">
          <h3 class="aboutTitle">About NewsBoard</h3>
          <p class="aboutText">NewsBoard is a newsroom tool for quickly checking the lead story or centerpiece across major news sites. It tracks homepage changes over time, making it easy to see what moved, when headlines or links shifted, and to rewind the front page to review editorial decisions and recreate breaking news moments.</p>
        </div>
        <button id="menu-go-overview" class="btn" type="button">Overview</button>
        <button id="menu-go-data" class="btn" type="button">Data</button>
        <button id="menu-go-playxplay" class="btn" type="button">Play x Play</button>
        <button id="menu-go-labs" class="btn" type="button">Labs</button>
      </div>
    </div>
  </aside>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <script>
    const $ = (id) => document.getElementById(id);

    const isLocal =
      location.hostname === "localhost" ||
      location.hostname === "127.0.0.1";

    const isGitHubPages =
      location.hostname.endsWith("github.io");

    const CACHE_URL = "./cache.json";
    const TIMELINE_URL = "./data/timeline.json";
    const TOP10_ABC_LATEST_URL = "./data/top10_abc_latest.json";
    const TOP10_ABC_HISTORY_URL = "./data/top10_abc_history.json";
    const SUPABASE_CONFIG_URL = "./supabase.json";
    const SUPABASE_PROXY_URL = "/api/supabase-snapshot";
    const SUPABASE_SCREENSHOT_BUCKET = "screenshots";

    // Expect exactly these sources; render placeholders when missing
    const EXPECTED_SOURCE_IDS = ["abc1","cbs1","usat1","nbc1","cnn1","guardian1","ap1","latimes1","npr1","bbc1","fox1","yahoo1"];

    // Supabase singleton (avoid multiple GoTrueClient instances)
    let _supabaseCfg = null;
    let _supabaseModPromise = null;
    let _supabaseClient = null;

    async function getSupabaseClient(){
      if (_supabaseClient) return _supabaseClient;
      if (!_supabaseCfg) _supabaseCfg = await loadSupabaseConfig();
      if (!_supabaseCfg) return null;
      if (!_supabaseModPromise) {
        _supabaseModPromise = import("https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm");
      }
      const mod = await _supabaseModPromise;
      _supabaseClient = mod.createClient(_supabaseCfg.url, _supabaseCfg.anonKey);
      return _supabaseClient;
    }

    const HISTORY_WINDOW_OPTIONS = [6, 24, 168];
    const HISTORY_WINDOW_DEFAULT_HOURS = 24;
    const DEEP_DIVE_DEFAULT_HOURS = 24;
    const deepDiveState = {
      latest: null,
      historyRuns: [],
      windowHours: DEEP_DIVE_DEFAULT_HOURS,
      selectedObservedAt: null,
    };
    const VIEW_STORAGE_KEY = "newsboard_view";
    const CLUSTER_PINNED_KEY = "nb_pinned_clusters";
    const CLUSTER_ACTIVE_KEY = "nb_active_clusters";
    const CLUSTER_DISMISSED_KEY = "nb_cluster_dismissed";
    const CLUSTER_CARD_ORDER_KEY = "nb_cluster_card_order";
    let activeView = "overview";
    let selectedWindowHours = HISTORY_WINDOW_DEFAULT_HOURS;
    let latestDrawerPayload = { normalizedHistory: null, sources: null, indicators: null };
    let latestOverviewPayload = { sources: {}, indicators: {}, timelineBySource: {} };
    let dataSortState = { key: "publisher", dir: "asc" };
    let selectedSourceDataId = "";
    let sourceDataWindowHours = HISTORY_WINDOW_DEFAULT_HOURS;
    let selectedDetailsTab = "changes";
    let clusterCardOrder = {};
    let isRefreshing = false;
    let lastRefreshError = null;
    let lastSuccessfulUpdateTs = 0;
    const PLAY_X_PLAY_RECENT_LIMIT = 16;

    const DEFAULT_CLUSTERS = [
      {
        id: "trump",
        label: "Trump",
        priority: 100,
        includeAny: ["trump", "donald trump", "maga", "mar-a-lago", "jack smith"],
        includeAll: [],
        exclude: ["trumpet"],
        createdAt: new Date().toISOString(),
        pinned: true,
      },
      {
        id: "olympics",
        label: "Olympics",
        priority: 100,
        includeAny: ["olympics", "olympic", "ioc", "team usa", "paris 2024", "la 2028"],
        includeAll: [],
        exclude: ["olympic peninsula", "olympia"],
        createdAt: new Date().toISOString(),
        pinned: true,
      },
    ];

    // UI rules
    const STALE_MS = 2 * 60 * 60 * 1000; // 2 hours

    function fmtTime(ts) {
      if (!ts) return "—";
      try {
        return new Date(ts).toLocaleString(undefined, {
          month: "short",
          day: "numeric",
          hour: "numeric",
          minute: "2-digit",
        });
      } catch {
        return "—";
      }
    }

    function ago(ts) {
      if (!ts) return "—";
      const t = new Date(ts).getTime();
      if (!Number.isFinite(t)) return "—";
      const s = Math.max(0, Math.floor((Date.now() - t) / 1000));
      if (s < 60) return `${s}s ago`;
      const m = Math.floor(s / 60);
      if (m < 60) return `${m}m ago`;
      const h = Math.floor(m / 60);
      if (h < 48) return `${h}h ago`;
      const d = Math.floor(h / 24);
      return `${d}d ago`;
    }

    function fmtDurationSeconds(seconds){
      const s0 = Number(seconds);
      if (!Number.isFinite(s0) || s0 < 0) return "—";
      const s = Math.floor(s0);
      if (s < 60) return `${s}s`;
      const m = Math.floor(s / 60);
      if (m < 60) return `${m}m`;
      const h = Math.floor(m / 60);
      if (h < 48) return `${h}h`;
      const d = Math.floor(h / 24);
      return `${d}d`;
    }

    function fmtDurationMs(ms){
      const v = Number(ms);
      if (!Number.isFinite(v) || v < 0) return "—";
      return fmtDurationSeconds(Math.floor(v / 1000));
    }

    function fmtWindowRange(windowSpec){
      const startMs = windowStartMs(windowSpec);
      const endMs = Date.now();
      const start = new Date(startMs);
      const end = new Date(endMs);
      const dateFmt = new Intl.DateTimeFormat(undefined, { month: "short", day: "numeric" });
      const timeFmt = new Intl.DateTimeFormat(undefined, { hour: "numeric", minute: "2-digit" });
      return `${dateFmt.format(start)} ${timeFmt.format(start)} - ${dateFmt.format(end)} ${timeFmt.format(end)}`;
    }

    function parseHoursSpec(windowSpec){
      const n = Number(windowSpec);
      if (!Number.isFinite(n)) return HISTORY_WINDOW_DEFAULT_HOURS;
      if (HISTORY_WINDOW_OPTIONS.includes(n)) return n;
      return HISTORY_WINDOW_DEFAULT_HOURS;
    }

    function windowStartMs(windowSpec){
      const hours = parseHoursSpec(windowSpec);
      return Date.now() - (hours * 60 * 60 * 1000);
    }

    function syncWindowSelectors(windowSpec){
      const hours = String(parseHoursSpec(windowSpec));
      const historySel = $("history-window");
      const dataSel = $("data-window");
      if (historySel && historySel.value !== hours) historySel.value = hours;
      if (dataSel && dataSel.value !== hours) dataSel.value = hours;
    }

    function rerenderDrawers(){
      const normalizedHistory = latestDrawerPayload?.normalizedHistory;
      const sources = latestDrawerPayload?.sources;
      const indicators = latestDrawerPayload?.indicators;
      if (!normalizedHistory || !sources || !indicators) return;
      renderData(normalizedHistory, indicators, sources, selectedWindowHours);
      renderHistory(normalizedHistory, sources, indicators, {
        hostId: "playxplay-history",
        useWindow: false,
        recentLimit: PLAY_X_PLAY_RECENT_LIMIT,
      });
      const sourceDrawerOpen = $("drawer-source-data")?.classList.contains("open");
      if (sourceDrawerOpen && selectedSourceDataId) {
        renderSourceDataPanel(selectedSourceDataId);
      }
    }

    function setSelectedWindowHours(windowSpec){
      selectedWindowHours = parseHoursSpec(windowSpec);
      syncWindowSelectors(selectedWindowHours);
      rerenderDrawers();
    }

    function showToast(text) {
      const el = $("toast");
      el.textContent = text;
      el.classList.add("show");
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => el.classList.remove("show"), 1200);
    }

    function summarizeError(err){
      const raw = String(err?.message || err || "").trim();
      if (!raw) return "Unknown error";
      return raw.replace(/\s+/g, " ").slice(0, 120);
    }

    function renderStatusLine(){
      const subline = $("subline");
      const refreshIndicator = $("refresh-indicator");
      const tsLabel = lastSuccessfulUpdateTs ? fmtTime(new Date(lastSuccessfulUpdateTs).toISOString()) : "—";

      if (refreshIndicator) refreshIndicator.textContent = isRefreshing ? "⟳ Refreshing" : "";
      if (!subline) return;

      if (lastRefreshError) {
        subline.textContent = `Last refresh failed — showing cached data. Last successful update: ${tsLabel}`;
        return;
      }
      if (lastSuccessfulUpdateTs) {
        subline.textContent = `Last update: ${tsLabel}`;
        return;
      }
      subline.textContent = isRefreshing ? "Refreshing…" : "Top story tracker";
    }

    function setPlayXPlayStatus(text){
      const el = $("playxplay-status");
      if (!el) return;
      el.textContent = String(text || "");
    }

    let _shotLightbox = null;
    function ensureShotLightbox(){
      if (_shotLightbox) return _shotLightbox;

      const root = document.createElement("div");
      root.style.position = "fixed";
      root.style.inset = "0";
      root.style.background = "rgba(0,0,0,.72)";
      root.style.display = "none";
      root.style.alignItems = "center";
      root.style.justifyContent = "center";
      root.style.padding = "24px";
      root.style.zIndex = "1000";

      const panel = document.createElement("div");
      panel.style.width = "min(1880px, 99.5vw)";
      panel.style.maxHeight = "98vh";
      panel.style.display = "flex";
      panel.style.flexDirection = "column";
      panel.style.gap = "10px";
      panel.style.background = "#111";
      panel.style.border = "1px solid rgba(255,255,255,.16)";
      panel.style.borderRadius = "12px";
      panel.style.padding = "10px";

      const meta = document.createElement("div");
      meta.style.color = "#f1f3f4";
      meta.style.fontSize = "12px";
      meta.style.whiteSpace = "nowrap";
      meta.style.overflow = "hidden";
      meta.style.textOverflow = "ellipsis";
      meta.style.flex = "1 1 auto";
      meta.style.minWidth = "0";

      const controlsRow = document.createElement("div");
      controlsRow.style.display = "flex";
      controlsRow.style.alignItems = "center";
      controlsRow.style.gap = "8px";
      controlsRow.style.flexWrap = "wrap";

      const btnClose = document.createElement("button");
      btnClose.className = "linkbtn";
      btnClose.type = "button";
      btnClose.textContent = "Close";

      const btnZoomOut = document.createElement("button");
      btnZoomOut.className = "linkbtn";
      btnZoomOut.type = "button";
      btnZoomOut.textContent = "−";

      const btnZoomReset = document.createElement("button");
      btnZoomReset.className = "linkbtn";
      btnZoomReset.type = "button";
      btnZoomReset.textContent = "100%";

      const btnZoomIn = document.createElement("button");
      btnZoomIn.className = "linkbtn";
      btnZoomIn.type = "button";
      btnZoomIn.textContent = "+";

      controlsRow.appendChild(meta);
      controlsRow.appendChild(btnZoomOut);
      controlsRow.appendChild(btnZoomReset);
      controlsRow.appendChild(btnZoomIn);
      controlsRow.appendChild(btnClose);

      const frame = document.createElement("div");
      frame.style.width = "100%";
      frame.style.height = "min(96vh, 1800px)";
      frame.style.borderRadius = "10px";
      frame.style.overflow = "hidden";
      frame.style.background = "#000";
      frame.style.display = "flex";
      frame.style.alignItems = "center";
      frame.style.justifyContent = "center";
      frame.style.padding = "10px";
      frame.style.touchAction = "pan-y";

      const img = document.createElement("img");
      img.alt = "";
      img.style.maxWidth = "99%";
      img.style.maxHeight = "99%";
      img.style.objectFit = "contain";
      img.style.transformOrigin = "center center";
      img.style.willChange = "transform";
      img.style.cursor = "grab";

      const sliderRow = document.createElement("div");
      sliderRow.style.display = "flex";
      sliderRow.style.alignItems = "center";
      sliderRow.style.gap = "8px";
      sliderRow.style.marginTop = "2px";
      sliderRow.style.paddingBottom = "calc(env(safe-area-inset-bottom, 0px) + 26px)";

      const slider = document.createElement("input");
      slider.type = "range";
      slider.min = "0";
      slider.max = "0";
      slider.step = "1";
      slider.value = "0";
      slider.style.width = "100%";
      slider.style.accentColor = "var(--blue)";

      frame.appendChild(img);

      panel.appendChild(frame);
      sliderRow.appendChild(slider);
      panel.appendChild(sliderRow);
      panel.appendChild(controlsRow);
      root.appendChild(panel);
      document.body.appendChild(root);

      let events = [];
      let idx = 0;
      let zoom = 1;
      let panX = 0;
      let panY = 0;
      let pinchStart = null;
      let panStart = null;
      function clampZoom(v){
        return Math.max(1, Math.min(4, v));
      }
      function applyZoom(){
        img.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
        img.style.cursor = zoom > 1 ? "grab" : "default";
        btnZoomReset.textContent = `${Math.round(zoom * 100)}%`;
      }
      function render(){
        const ev = events[idx] || null;
        if (!ev || !ev.shot_url) return;
        img.src = ev.shot_url;
        applyZoom();
        meta.textContent = `${fmtTime(ev.ts)}`;
        slider.max = String(Math.max(0, events.length - 1));
        slider.value = String(idx);
      }

      function close(){
        root.style.display = "none";
      }

      btnClose.addEventListener("click", close);
      root.addEventListener("click", (e) => {
        if (e.target === root) close();
      });
      slider.addEventListener("input", () => {
        idx = Math.max(0, Math.min(events.length - 1, Number(slider.value || 0)));
        render();
      });
      btnZoomIn.addEventListener("click", () => {
        zoom = clampZoom(zoom + 0.2);
        if (zoom <= 1) { panX = 0; panY = 0; }
        applyZoom();
      });
      btnZoomOut.addEventListener("click", () => {
        zoom = clampZoom(zoom - 0.2);
        if (zoom <= 1) { panX = 0; panY = 0; }
        applyZoom();
      });
      btnZoomReset.addEventListener("click", () => {
        zoom = 1;
        panX = 0;
        panY = 0;
        applyZoom();
      });
      frame.addEventListener("wheel", (e) => {
        e.preventDefault();
        const delta = e.deltaY < 0 ? 0.12 : -0.12;
        zoom = clampZoom(zoom + delta);
        if (zoom <= 1) { panX = 0; panY = 0; }
        applyZoom();
      }, { passive: false });

      img.addEventListener("mousedown", (e) => {
        if (zoom <= 1) return;
        panStart = {
          x: e.clientX,
          y: e.clientY,
          panX,
          panY,
        };
        img.style.cursor = "grabbing";
        e.preventDefault();
      });
      window.addEventListener("mousemove", (e) => {
        if (!panStart || zoom <= 1) return;
        panX = panStart.panX + (e.clientX - panStart.x);
        panY = panStart.panY + (e.clientY - panStart.y);
        applyZoom();
      });
      window.addEventListener("mouseup", () => {
        if (!panStart) return;
        panStart = null;
        img.style.cursor = zoom > 1 ? "grab" : "default";
      });

      let touchStartX = null;
      frame.addEventListener("touchstart", (e) => {
        if ((e.touches?.length || 0) === 2) {
          const a = e.touches[0];
          const b = e.touches[1];
          pinchStart = Math.hypot(a.clientX - b.clientX, a.clientY - b.clientY);
          return;
        }
        if ((e.touches?.length || 0) === 1 && zoom > 1) {
          const t = e.touches[0];
          panStart = {
            x: t.clientX,
            y: t.clientY,
            panX,
            panY,
          };
          return;
        }
        touchStartX = e.touches?.[0]?.clientX ?? null;
      }, { passive: true });
      frame.addEventListener("touchmove", (e) => {
        if ((e.touches?.length || 0) !== 2 || !pinchStart) return;
        const a = e.touches[0];
        const b = e.touches[1];
        const d = Math.hypot(a.clientX - b.clientX, a.clientY - b.clientY);
        const ratio = d / pinchStart;
        zoom = clampZoom(zoom * ratio);
        if (zoom <= 1) { panX = 0; panY = 0; }
        pinchStart = d;
        applyZoom();
      }, { passive: true });
      frame.addEventListener("touchmove", (e) => {
        if ((e.touches?.length || 0) !== 1 || !panStart || zoom <= 1) return;
        const t = e.touches[0];
        panX = panStart.panX + (t.clientX - panStart.x);
        panY = panStart.panY + (t.clientY - panStart.y);
        applyZoom();
      }, { passive: true });
      frame.addEventListener("touchend", (e) => {
        if ((e.touches?.length || 0) < 2) pinchStart = null;
        if ((e.touches?.length || 0) === 0) panStart = null;
        if (zoom > 1) return;
        const endX = e.changedTouches?.[0]?.clientX ?? null;
        if (touchStartX === null || endX === null) return;
        const dx = endX - touchStartX;
        touchStartX = null;
        if (Math.abs(dx) < 40) return;
        if (dx < 0 && idx < events.length - 1) idx += 1;
        if (dx > 0 && idx > 0) idx -= 1;
        render();
      }, { passive: true });

      _shotLightbox = {
        open(nextEvents, startIdx){
          events = Array.isArray(nextEvents) ? nextEvents.filter((e) => e?.shot_url) : [];
          if (!events.length) return;
          idx = Math.max(0, Math.min(events.length - 1, Number(startIdx) || 0));
          zoom = 1;
          panX = 0;
          panY = 0;
          root.style.display = "flex";
          render();
        },
        close,
      };
      return _shotLightbox;
    }

    function closeAllDrawers() {
      const ids = ["drawer-history", "drawer-data", "drawer-source-data", "drawer-menu"];
      for (const id of ids) {
        const d = $(id);
        if (!d) continue;
        d.classList.remove("open");
        d.setAttribute("aria-hidden", "true");
      }
      $("drawer-overlay")?.classList.remove("show");
    }

    function setMenuOpen(open){
      const drawer = $("drawer-menu");
      const overlay = $("drawer-overlay");
      if (!drawer || !overlay) return;
      if (open) closeAllDrawers();
      drawer.classList.toggle("open", Boolean(open));
      overlay.classList.toggle("show", Boolean(open));
      drawer.setAttribute("aria-hidden", open ? "false" : "true");
    }

    function setHistoryOpen(open){
      const drawer = $("drawer-history");
      const overlay = $("drawer-overlay");
      const btn = $("btn-history");
      if (!drawer || !overlay) return;
      if (open) {
        closeAllDrawers();
      }
      drawer.classList.toggle("open", Boolean(open));
      overlay.classList.toggle("show", Boolean(open));
      drawer.setAttribute("aria-hidden", open ? "false" : "true");
      if (!open && btn) btn.focus();
    }

    function setSourceDataOpen(open, sourceId = selectedSourceDataId){
      const drawer = $("drawer-source-data");
      const overlay = $("drawer-overlay");
      const sel = $("source-data-window");
      if (!drawer || !overlay) return;
      if (open) {
        closeAllDrawers();
      }
      selectedSourceDataId = sourceId || selectedSourceDataId || "";
      if (sel) sel.value = String(parseHoursSpec(sourceDataWindowHours));
      if (open && selectedSourceDataId) {
        renderSourceDataPanel(selectedSourceDataId);
      }
      drawer.classList.toggle("open", Boolean(open));
      overlay.classList.toggle("show", Boolean(open));
      drawer.setAttribute("aria-hidden", open ? "false" : "true");
    }

    function setDetailsTab(tab){
      const valid = new Set(["changes", "data", "shots"]);
      selectedDetailsTab = valid.has(tab) ? tab : "changes";
      const tabs = [
        ["details-tab-changes", "changes"],
        ["details-tab-data", "data"],
        ["details-tab-shots", "shots"],
      ];
      for (const [id, key] of tabs) {
        const btn = $(id);
        if (!btn) continue;
        const active = key === selectedDetailsTab;
        btn.classList.toggle("active", active);
        btn.setAttribute("aria-selected", active ? "true" : "false");
      }
      if (selectedSourceDataId) renderSourceDataPanel(selectedSourceDataId);
    }

    function setDataOpen(open){
      const drawer = $("drawer-data");
      const overlay = $("drawer-overlay");
      const btn = $("tab-data");
      if (!drawer || !overlay) return;
      if (open) {
        closeAllDrawers();
      }
      drawer.classList.toggle("open", Boolean(open));
      overlay.classList.toggle("show", Boolean(open));
      drawer.setAttribute("aria-hidden", open ? "false" : "true");
      if (!open && btn) btn.focus();
    }

    function canonicalSourceId(rawId){
      const s = String(rawId || "")
        .toLowerCase()
        .trim()
        .replace(/[^a-z0-9]/g, "");
      if (!s) return "";
      if (s === "abc" || s === "abc1") return "abc1";
      if (s === "cbs" || s === "cbs1") return "cbs1";
      if (s === "usat" || s === "usat1" || s === "usatoday" || s === "usatoday1") return "usat1";
      if (s === "nbc" || s === "nbc1") return "nbc1";
      if (s === "cnn" || s === "cnn1") return "cnn1";
      if (s === "reuters" || s === "reuters1") return "guardian1";
      if (s === "guardian" || s === "guardian1") return "guardian1";
      if (s === "ap" || s === "ap1" || s === "associatedpress") return "ap1";
      if (s === "latimes" || s === "latimes1" || s === "losangelestimes") return "latimes1";
      if (s === "wsj" || s === "wsj1" || s === "wallstreetjournal") return "";
      if (s === "npr" || s === "npr1" || s === "nationalpublicradio") return "npr1";
      if (s === "bbc" || s === "bbc1") return "bbc1";
      if (s === "fox" || s === "fox1") return "fox1";
      if (s === "yahoo" || s === "yahoo1" || s === "yahoonews") return "yahoo1";
      if (s === "wp" || s === "wp1" || s === "wapo" || s === "washingtonpost") return "yahoo1";
      return s;
    }

    function mergeSourceRows(prev, next){
      if (!prev) return next;
      const prevTs = Date.parse(prev?.updatedAt || prev?.lastChangeAt || "");
      const nextTs = Date.parse(next?.updatedAt || next?.lastChangeAt || "");
      const chooseNext = Number.isFinite(nextTs) && (!Number.isFinite(prevTs) || nextTs >= prevTs);
      const newer = chooseNext ? next : prev;
      const older = chooseNext ? prev : next;
      return {
        ...older,
        ...newer,
        item: { ...(older?.item || {}), ...(newer?.item || {}) },
      };
    }

    function sourceLabel(k, row){
      // Normalize IDs coming from Supabase/views (case, punctuation, aliases)
      const s = canonicalSourceId(k);
      const n = row?.sourceName || row?.name || null;
      if (s === "yahoo1") return "Yahoo News";
      if (s === "guardian1") return "The Guardian";
      if (n) return String(n);

      if (s === "abc" || s === "abc1") return "ABC News";
      if (s === "cbs" || s === "cbs1") return "CBS News";
      if (s === "usat" || s === "usat1" || s === "usatoday" || s === "usatoday1") return "USA Today";
      if (s === "nbc" || s === "nbc1") return "NBC News";
      if (s === "cnn" || s === "cnn1") return "CNN";
      if (s === "guardian" || s === "guardian1") return "The Guardian";
      if (s === "ap" || s === "ap1" || s === "associatedpress") return "Associated Press";
      if (s === "latimes" || s === "latimes1" || s === "losangelestimes") return "Los Angeles Times";
      if (s === "npr" || s === "npr1" || s === "nationalpublicradio") return "NPR";
      if (s === "bbc" || s === "bbc1") return "BBC";
      if (s === "fox" || s === "fox1") return "Fox News";

      return k || "Source";
    }

    function sourceHomeUrl(k, row){
      const s = canonicalSourceId(k);
      if (s === "guardian1") return "https://www.theguardian.com/";
      if (s === "yahoo1") return "https://news.yahoo.com/";
      const fromRow = row?.home_url || row?.homeUrl || null;
      if (fromRow) return String(fromRow);
      if (s === "abc1") return "https://abcnews.com/";
      if (s === "cbs1") return "https://www.cbsnews.com/";
      if (s === "usat1") return "https://www.usatoday.com/";
      if (s === "nbc1") return "https://www.nbcnews.com/";
      if (s === "cnn1") return "https://www.cnn.com/";
      if (s === "ap1") return "https://apnews.com/";
      if (s === "latimes1") return "https://www.latimes.com/";
      if (s === "npr1") return "https://www.npr.org/";
      if (s === "bbc1") return "https://www.bbc.com/";
      if (s === "fox1") return "https://www.foxnews.com/";
      return null;
    }

    function copyText(txt){
      if (!txt) return;
      return navigator.clipboard.writeText(txt);
    }

    async function fetchJSON(url, opts) {
      const r = await fetch(url, opts);
      const text = await r.text();
      try { return JSON.parse(text); }
      catch { throw new Error(text || `HTTP ${r.status}`); }
    }

    async function loadSupabaseConfig(){
      try{
        const cfg = await fetchJSON(`${SUPABASE_CONFIG_URL}?ts=${Date.now()}`);
        if (!cfg || !cfg.url || !cfg.anonKey) return null;
        return { url: String(cfg.url), anonKey: String(cfg.anonKey) };
      } catch {
        return null;
      }
    }

    async function loadFromSupabase(){
      if (isGitHubPages) return null;

      // Prefer same-origin proxy when available; this avoids browser CORS issues.
      try {
        const proxied = await fetchJSON(`${SUPABASE_PROXY_URL}?ts=${Date.now()}`);
        if (proxied?.ok && proxied?.cacheLike) {
          return { cacheLike: proxied.cacheLike, history: proxied.history || null };
        }
      } catch {
        // Ignore and continue to optional direct browser fallback below.
      }

      const supabase = await getSupabaseClient();
      if (!supabase) return null;

      function pick(row, keys){
        for (const k of keys){
          const v = row?.[k];
          if (v === null || v === undefined) continue;
          if (typeof v === "string" && !v.trim()) continue;
          return v;
        }
        return null;
      }

      const cur = await supabase.from("v_current_hero_since").select("*");
      if (cur.error) throw cur.error;

      const hist = await supabase
        .from("v_history_hero_stories")
        .select("*")
        .order("last_seen_at", { ascending: false })
        .limit(200);
      if (hist.error) throw hist.error;

      const sources = {};
      for (const row of (cur.data || [])){
        const id = canonicalSourceId(row.source_id || row.id || "");
        if (!id) continue;

        const firstSeenAt = pick(row, ["first_seen_at", "firstSeenAt", "since_at", "current_since_at"]);
        const secondsInTop = pick(row, ["seconds_in_top", "secondsInTop", "seconds_in_slot", "seconds_in_current"]);

        const mapped = {
          ok: row.ok !== false,
          updatedAt: row.observed_at || row.updated_at || row.last_seen_at || null,
          firstSeenAt,
          secondsInTop,
          error: row.error || null,
          runId: row.run_id || null,

          sourceName: row.source_name || row.sourceName || row.name || null,
          changeType: row.change_type || row.changeType || null,
          isStale: Boolean(row.is_stale ?? row.isStale ?? false),
          lastChangeAt: row.last_change_at || row.lastChangeAt || null,

          item: {
            title: row.title || null,
            url: row.url || null,
            contentType: row.content_type || row.contentType || null,
          },
        };
        sources[id] = mergeSourceRows(sources[id], mapped);
      }

      const historyObj = { generatedAt: new Date().toISOString(), sources: {} };
      for (const row of (hist.data || [])){
        const id = canonicalSourceId(pick(row, ["source_id", "source", "id"]) || "");
        if (!id) continue;
        if (!historyObj.sources[id]) historyObj.sources[id] = { entries: [] };

        const url = pick(row, ["url", "story_url", "hero_url", "link", "href"]);
        const title = pick(row, ["title", "any_title", "story_title", "headline", "hero_title"]);
        const firstSeenAt = pick(row, ["first_seen_at", "firstSeenAt", "first_seen", "first_seen_ts"]);
        const lastSeenAt = pick(row, ["last_seen_at", "lastSeenAt", "last_seen", "observed_at", "updated_at", "updatedAt"]);
        const seenCount = pick(row, ["seen_count", "seenCount", "count", "observations"]);

        historyObj.sources[id].entries.push({ url, title, firstSeenAt, lastSeenAt, seenCount });
      }

      // Align to cache.json-like structure for renderer
      const cacheLike = { generatedAt: new Date().toISOString(), sources };

      return { cacheLike, history: historyObj };
    }

    function renderHistory(history, currentSources, indicatorsById = {}, options = {}){
      const host = $(options?.hostId || "history");
      if (!host) return;
      host.innerHTML = "";

      const useWindow = Boolean(options?.useWindow);
      const cutoffMs = windowStartMs(options?.windowSpec ?? selectedWindowHours);
      const recentLimit = Math.max(1, Number(options?.recentLimit || 16));
      function inWindow(x){
        if (!useWindow) return true;
        const t = Date.parse(x?.lastSeenAt || x?.firstSeenAt || "");
        return Number.isFinite(t) ? t >= cutoffMs : false;
      }

      const sources = history && typeof history === "object" && history.sources && typeof history.sources === "object" ? history.sources : {};

      const latestRows = [];
      for (const [sourceId, src] of Object.entries(currentSources || {})) {
        const item = src?.item || {};
        const title = String(item.title || "").trim();
        const url = String(item.url || "").trim();
        const historyEntries = Array.isArray(sources?.[sourceId]?.entries) ? sources[sourceId].entries : [];
        const latestHist = Array.isArray(historyEntries) && historyEntries.length
          ? historyEntries[historyEntries.length - 1]
          : null;

        const ind = indicatorsById?.[sourceId] || { changeType: null, stale2h: false };
        const stale2h = Boolean(src?.isStale) || Boolean(ind?.stale2h);
        const latestChangeType = ind?.changeType || null;

        const tRaw = src?.updatedAt || src?.lastChangeAt || latestHist?.lastSeenAt || latestHist?.firstSeenAt || null;
        const tMs = Number.isFinite(Date.parse(tRaw || "")) ? Date.parse(tRaw) : 0;
        if (!tMs) continue;

        latestRows.push({
          source: sourceId,
          title: title || "—",
          url: url || "#",
          updatedAt: tRaw,
          __changeType: latestChangeType,
          __stale2h: stale2h,
          __tMs: tMs,
        });
      }

      latestRows.sort((a, b) => {
        if (b.__tMs !== a.__tMs) return b.__tMs - a.__tMs;
        return String(a.source || "").localeCompare(String(b.source || ""));
      });

      const section = document.createElement("section");
      section.className = "historySection";

      const sectionTitle = document.createElement("div");
      sectionTitle.className = "historySectionTitle";
      sectionTitle.textContent = "Most recent updates";
      section.appendChild(sectionTitle);

      const unifiedList = document.createElement("div");
      unifiedList.className = "historyList";
      section.appendChild(unifiedList);
      host.appendChild(section);

      if (latestRows.length) {
        for (const row of latestRows.slice(0, recentLimit)) {
          const card = document.createElement("article");
          card.className = "latestItem";

          const meta = document.createElement("div");
          meta.className = "latestMetaRow";

          const left = document.createElement("div");
          left.className = "srcTitle";

          const leftMeta = document.createElement("div");
          leftMeta.className = "srcMeta srcMetaInline";
          const sourceName = document.createElement("div");
          sourceName.className = "srcName";
          sourceName.textContent = sourceLabel(row.source, null);
          leftMeta.appendChild(sourceName);
          const when = document.createElement("div");
          when.className = "srcTime";
          when.textContent = row.updatedAt ? `${fmtTime(row.updatedAt)} · ${ago(row.updatedAt)}` : "—";
          leftMeta.appendChild(when);

          left.appendChild(leftMeta);
          meta.appendChild(left);

          const h = document.createElement("h3");
          h.className = "latestTitle";
          const a = document.createElement("a");
          a.href = row.url || "#";
          a.target = "_blank";
          a.rel = "noopener";
          a.textContent = row.title || "—";
          h.appendChild(a);

          card.appendChild(meta);

          const body = document.createElement("div");
          body.className = "latestBody";

          const main = document.createElement("div");
          main.className = "latestMain";
          main.appendChild(h);
          body.appendChild(main);
          card.appendChild(body);
          unifiedList.appendChild(card);
        }
      }

      const rows = [];
      for (const [source, obj] of Object.entries(sources)){
        const entries = Array.isArray(obj?.entries) ? obj.entries : [];
        const filtered = entries.filter(inWindow);
        for (let i = 0; i < filtered.length; i++){
          const e = filtered[i];
          if (!e || !e.url) continue;

          const prev = i - 1 >= 0 ? filtered[i - 1] : null;
          const isHeadlineChange = Boolean(prev && prev.url === e.url && String(prev.title || "") !== String(e.title || ""));
          const isNewUrl = Boolean(!prev || prev.url !== e.url);

          rows.push({
            source,
            __changeType: isHeadlineChange ? "headline" : (isNewUrl ? "url" : "other"),
            ...e,
          });
        }
      }

      function activityTime(x){
        const t = Date.parse(x?.lastSeenAt || x?.firstSeenAt || "");
        return Number.isFinite(t) ? t : 0;
      }

      rows.sort((a,b) => {
        const ta = activityTime(a);
        const tb = activityTime(b);
        if (tb !== ta) return tb - ta;

        const sa = String(a.source || "");
        const sb = String(b.source || "");
        if (sa !== sb) return sa.localeCompare(sb);

        const ua = String(a.url || "");
        const ub = String(b.url || "");
        if (ua !== ub) return ua.localeCompare(ub);

        const tla = String(a.title || "");
        const tlb = String(b.title || "");
        return tla.localeCompare(tlb);
      });

      if (!rows.length && !latestRows.length){
        const empty = document.createElement("div");
        empty.className = "tiny";
        empty.style.color = "var(--muted)";
        empty.textContent = "No history yet.";
        unifiedList.appendChild(empty);
        return;
      }

      const fullSection = document.createElement("section");
      fullSection.className = "historySection";
      const fullTitle = document.createElement("div");
      fullTitle.className = "historySectionTitle";
      fullTitle.textContent = "Full history";
      fullSection.appendChild(fullTitle);

      const toggle = document.createElement("button");
      toggle.type = "button";
      toggle.className = "linkbtn";
      toggle.textContent = "Show all";
      fullSection.appendChild(toggle);

      const fullList = document.createElement("div");
      fullList.className = "historyList";
      fullList.style.display = "none";
      fullSection.appendChild(fullList);
      host.appendChild(fullSection);

      toggle.addEventListener("click", () => {
        const show = fullList.style.display === "none";
        fullList.style.display = show ? "" : "none";
        toggle.textContent = show ? "Hide all" : "Show all";
      });

      for (const it of rows){
        const card = document.createElement("section");
        card.className = "hItem";

        const head = document.createElement("div");
        head.className = "hHead";

        const left = document.createElement("div");
        left.className = "srcTitle";

        const meta = document.createElement("div");
        meta.className = "srcMeta srcMetaInline";
        const name = document.createElement("div");
        name.className = "srcName";
        name.textContent = sourceLabel(it.source, null);
        meta.appendChild(name);
        const updated = document.createElement("div");
        updated.className = "srcTime";
        updated.textContent = it.lastSeenAt ? `${fmtTime(it.lastSeenAt)} · ${ago(it.lastSeenAt)}` : "—";
        meta.appendChild(updated);

        left.appendChild(meta);
        head.appendChild(left);

        const body = document.createElement("div");
        body.className = "hBody";

        const main = document.createElement("div");
        main.className = "hMain";

        const title = document.createElement("h3");
        title.className = "hTitle";
        const a = document.createElement("a");
        a.href = it.url || "#";
        a.target = "_blank";
        a.rel = "noopener";
        a.textContent = it.title || "—";
        title.appendChild(a);

        main.appendChild(title);

        body.appendChild(main);

        card.appendChild(head);
        card.appendChild(body);

        fullList.appendChild(card);
      }
    }

    function historyEntryBoundsMs(entry){
      const start = Date.parse(String(entry?.firstSeenAt || entry?.lastSeenAt || ""));
      const endRaw = Date.parse(String(entry?.lastSeenAt || entry?.firstSeenAt || ""));
      if (!Number.isFinite(start) && !Number.isFinite(endRaw)) return null;
      const safeStart = Number.isFinite(start) ? start : endRaw;
      const safeEnd = Number.isFinite(endRaw) ? endRaw : safeStart;
      return {
        startMs: safeStart,
        endMs: safeEnd >= safeStart ? safeEnd : safeStart,
      };
    }

    function computeSourceDataMetrics(entries, windowSpec){
      const winStart = windowStartMs(windowSpec);
      const hours = parseHoursSpec(windowSpec);
      const daysDivisor = hours === 168 ? 7 : 1;
      const normalized = [...(Array.isArray(entries) ? entries : [])]
        .map((entry) => {
          const bounds = historyEntryBoundsMs(entry);
          if (!bounds) return null;
          return { ...entry, ...bounds };
        })
        .filter(Boolean)
        .sort((a, b) => {
          if (a.startMs !== b.startMs) return a.startMs - b.startMs;
          return a.endMs - b.endMs;
        });

      const inWindow = normalized.filter((entry) => entry.endMs >= winStart);
      // Stats derivation:
      // - URL change: consecutive entries with different canonical URL.
      // - Headline-only change: same canonical URL, different title.
      // - Unique stories: canonical URL count, with title fingerprint fallback when URL is missing.
      // - Longest run: max continuous duration for a single canonical URL/fingerprint in window.
      const canonicalKey = (entry) => {
        const rawUrl = String(entry?.url || "").trim().toLowerCase();
        if (rawUrl) {
          try {
            const u = new URL(rawUrl);
            u.hash = "";
            if (u.pathname.length > 1 && u.pathname.endsWith("/")) u.pathname = u.pathname.slice(0, -1);
            for (const k of [...u.searchParams.keys()]) {
              const lk = k.toLowerCase();
              if (lk.startsWith("utm_") || lk === "fbclid" || lk === "gclid") u.searchParams.delete(k);
            }
            u.searchParams.sort();
            return `u:${u.toString()}`;
          } catch {}
        }
        const t = String(entry?.title || "").trim().toLowerCase();
        return t ? `t:${t}` : "unknown";
      };
      const distinctUrls = new Set(inWindow.map((entry) => canonicalKey(entry)));

      let urlChanges = 0;
      let headlineOnlyChanges = 0;
      for (let i = 1; i < normalized.length; i += 1) {
        const prev = normalized[i - 1];
        const cur = normalized[i];
        if (cur.endMs < winStart) continue;

        const prevUrl = canonicalKey(prev);
        const curUrl = canonicalKey(cur);
        const prevTitle = String(prev?.title || "");
        const curTitle = String(cur?.title || "");

        if (curUrl !== prevUrl) {
          urlChanges += 1;
        } else if (curTitle !== prevTitle) {
          headlineOnlyChanges += 1;
        }
      }

      let longestRunMs = 0;
      let i = 0;
      while (i < normalized.length) {
        const first = normalized[i];
        const runUrl = canonicalKey(first);
        let runStart = first.startMs;
        let runEnd = first.endMs;
        let j = i + 1;
        while (j < normalized.length && canonicalKey(normalized[j]) === runUrl) {
          runEnd = Math.max(runEnd, normalized[j].endMs);
          j += 1;
        }
        if (runEnd >= winStart) {
          const boundedStart = Math.max(runStart, winStart);
          longestRunMs = Math.max(longestRunMs, Math.max(0, runEnd - boundedStart));
        }
        i = j;
      }

      const bucketMinutes = hours <= 6 ? 30 : 60;
      const bucketMs = bucketMinutes * 60 * 1000;
      const bucketCount = Math.max(1, Math.ceil((Date.now() - winStart) / bucketMs));
      const buckets = Array.from({ length: bucketCount }, (_, idx) => ({
        startMs: winStart + (idx * bucketMs),
        url: 0,
        headline: 0,
      }));
      for (let i = 1; i < normalized.length; i += 1) {
        const prev = normalized[i - 1];
        const cur = normalized[i];
        if (cur.endMs < winStart) continue;
        const idx = Math.min(bucketCount - 1, Math.max(0, Math.floor((cur.endMs - winStart) / bucketMs)));
        const prevKey = canonicalKey(prev);
        const curKey = canonicalKey(cur);
        if (curKey !== prevKey) buckets[idx].url += 1;
        else if (String(cur?.title || "") !== String(prev?.title || "")) buckets[idx].headline += 1;
      }

      return {
        urlChanges,
        headlineOnlyChanges,
        uniqueStories: distinctUrls.size,
        longestRunMs,
        urlChangesDisplay: urlChanges / daysDivisor,
        headlineOnlyChangesDisplay: headlineOnlyChanges / daysDivisor,
        uniqueStoriesDisplay: distinctUrls.size / daysDivisor,
        perDay: daysDivisor > 1,
        buckets,
      };
    }

    function fmtMetricValue(v, perDay){
      const n = Number(v);
      if (!Number.isFinite(n)) return "—";
      const rounded = perDay ? Math.round(n * 10) / 10 : Math.round(n);
      return perDay ? `${rounded.toFixed(1)}/day` : String(rounded);
    }

    function dataSortArrow(key){
      if (dataSortState.key !== key) return "↕";
      return dataSortState.dir === "asc" ? "↑" : "↓";
    }

    function toggleDataSort(key){
      if (dataSortState.key === key) {
        dataSortState = { key, dir: dataSortState.dir === "asc" ? "desc" : "asc" };
      } else {
        dataSortState = { key, dir: key === "publisher" ? "asc" : "desc" };
      }
      rerenderDrawers();
    }

    function renderData(normalizedHistory, indicatorsById = {}, currentSources = {}, windowSpec = selectedWindowHours){
      const host = $("data");
      if (!host) return;
      host.innerHTML = "";

      const historySources = normalizedHistory && typeof normalizedHistory === "object" && normalizedHistory.sources
        ? normalizedHistory.sources
        : {};

      const sourceIds = pickCardSourceIds(currentSources || {});
      const hasAnyRows = sourceIds.some((id) => {
        const hasEntries = Array.isArray(historySources?.[id]?.entries) && historySources[id].entries.length > 0;
        const hasCurrent = Boolean(currentSources?.[id]?.item?.url || currentSources?.[id]?.item?.title);
        return hasEntries || hasCurrent;
      });
      if (!sourceIds.length || !hasAnyRows) {
        const empty = document.createElement("div");
        empty.className = "tiny";
        empty.style.color = "var(--muted)";
        empty.textContent = "No data loaded.";
        host.appendChild(empty);
        return;
      }

      const winStart = windowStartMs(windowSpec);
      const now = Date.now();
      const rows = [];

      for (const sourceId of sourceIds) {
        const sourceRow = currentSources?.[sourceId] || null;
        const entries = Array.isArray(historySources?.[sourceId]?.entries) ? historySources[sourceId].entries : [];
        const metrics = computeSourceDataMetrics(entries, windowSpec);
        rows.push({
          sourceId,
          sourceRow,
          metrics,
          currentSinceAt: indicatorsById?.[sourceId]?.currentSinceAt || null,
          sortPublisher: sourceLabel(sourceId, sourceRow),
        });
      }

      rows.sort((a, b) => {
        const mult = dataSortState.dir === "asc" ? 1 : -1;
        const key = dataSortState.key;
        if (key === "publisher") {
          return mult * String(a.sortPublisher || "").localeCompare(String(b.sortPublisher || ""));
        }
        if (key === "urlChanges") {
          return mult * (a.metrics.urlChangesDisplay - b.metrics.urlChangesDisplay);
        }
        if (key === "longestRun") {
          return mult * (a.metrics.longestRunMs - b.metrics.longestRunMs);
        }
        if (key === "headlineOnly") {
          return mult * (a.metrics.headlineOnlyChangesDisplay - b.metrics.headlineOnlyChangesDisplay);
        }
        return 0;
      });

      const table = document.createElement("table");
      table.className = "dataTable";

      const thead = document.createElement("thead");
      const trHead = document.createElement("tr");
      const cols = [
        { key: "publisher", label: "Publisher" },
        { key: "urlChanges", label: "URL changes" },
        { key: "longestRun", label: "Longest run" },
        { key: "headlineOnly", label: "Headline Changes" },
      ];
      for (const col of cols) {
        const th = document.createElement("th");
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "dataSortBtn";
        btn.innerHTML = `${escapeHtml(col.label)} <span class="sortArrow">${escapeHtml(dataSortArrow(col.key))}</span>`;
        btn.addEventListener("click", () => toggleDataSort(col.key));
        th.appendChild(btn);
        trHead.appendChild(th);
      }
      thead.appendChild(trHead);
      table.appendChild(thead);

      const tbody = document.createElement("tbody");

      for (const row of rows) {
        const tr = document.createElement("tr");

        const tdPublisher = document.createElement("td");
        tdPublisher.className = "dataPublisherCell";
        tdPublisher.textContent = sourceLabel(row.sourceId, row.sourceRow);

        const currentSinceRaw = row.currentSinceAt;
        const currentSinceMs = Number.isFinite(Date.parse(String(currentSinceRaw || "")))
          ? Date.parse(String(currentSinceRaw || ""))
          : 0;
        if (currentSinceMs > 0) {
          const runLine = document.createElement("div");
          runLine.className = "tiny";
          runLine.textContent = `Current run ${fmtDurationMs(Math.max(0, now - Math.max(winStart, currentSinceMs)))}`;
          tdPublisher.appendChild(document.createElement("br"));
          tdPublisher.appendChild(runLine);
        }

        const tdUrl = document.createElement("td");
        tdUrl.textContent = fmtMetricValue(row.metrics.urlChangesDisplay, row.metrics.perDay);

        const tdLongest = document.createElement("td");
        tdLongest.textContent = fmtDurationMs(row.metrics.longestRunMs);

        const tdHeadline = document.createElement("td");
        tdHeadline.textContent = fmtMetricValue(row.metrics.headlineOnlyChangesDisplay, row.metrics.perDay);

        tr.appendChild(tdPublisher);
        tr.appendChild(tdUrl);
        tr.appendChild(tdLongest);
        tr.appendChild(tdHeadline);
        tbody.appendChild(tr);
      }

      table.appendChild(tbody);
      host.appendChild(table);
    }

    function drawMiniBars(canvas, buckets){
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      const dpr = window.devicePixelRatio || 1;
      const cssW = canvas.clientWidth || 300;
      const cssH = canvas.clientHeight || 120;
      canvas.width = Math.floor(cssW * dpr);
      canvas.height = Math.floor(cssH * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, cssW, cssH);
      const data = Array.isArray(buckets) ? buckets : [];
      if (!data.length) return;
      const max = Math.max(1, ...data.map((b) => Number(b.url || 0) + Number(b.headline || 0)));
      const gap = 2;
      const barW = Math.max(2, Math.floor((cssW - (data.length - 1) * gap) / data.length));
      let x = 0;
      for (const b of data) {
        const total = Number(b.url || 0) + Number(b.headline || 0);
        const h = Math.round((total / max) * (cssH - 12));
        ctx.fillStyle = "#E5E7EB";
        ctx.fillRect(x, cssH - h, barW, h);
        const hu = Math.round((Number(b.url || 0) / max) * (cssH - 12));
        const hh = Math.round((Number(b.headline || 0) / max) * (cssH - 12));
        ctx.fillStyle = "rgba(30,142,62,.9)";
        if (hu > 0) ctx.fillRect(x, cssH - hu, barW, hu);
        ctx.fillStyle = "rgba(23,92,211,.85)";
        if (hh > 0) ctx.fillRect(x, cssH - hu - hh, barW, hh);
        x += barW + gap;
      }
    }

    function drawSplitBars(canvas, metrics){
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      const dpr = window.devicePixelRatio || 1;
      const cssW = canvas.clientWidth || 300;
      const cssH = canvas.clientHeight || 120;
      canvas.width = Math.floor(cssW * dpr);
      canvas.height = Math.floor(cssH * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, cssW, cssH);
      const url = Number(metrics?.urlChanges || 0);
      const hl = Number(metrics?.headlineOnlyChanges || 0);
      const max = Math.max(1, url, hl);
      const barW = Math.floor((cssW - 48) / 2);
      const baseY = cssH - 18;
      const h1 = Math.round((url / max) * (cssH - 32));
      const h2 = Math.round((hl / max) * (cssH - 32));
      ctx.fillStyle = "rgba(30,142,62,.9)";
      ctx.fillRect(14, baseY - h1, barW, h1);
      ctx.fillStyle = "rgba(23,92,211,.9)";
      ctx.fillRect(28 + barW, baseY - h2, barW, h2);
      ctx.fillStyle = "#5e6977";
      ctx.font = "11px sans-serif";
      ctx.fillText("URL", 14, cssH - 4);
      ctx.fillText("Headline", 28 + barW, cssH - 4);
    }

    function renderSourceDataPanel(sourceId){
      const host = $("source-data");
      const title = $("source-data-title");
      const range = $("source-data-range");
      if (!host || !title) return;
      host.innerHTML = "";

      const normalizedHistory = latestDrawerPayload?.normalizedHistory || { sources: {} };
      const indicatorsById = latestDrawerPayload?.indicators || {};
      const currentSources = latestDrawerPayload?.sources || {};
      const sourceRow = currentSources?.[sourceId] || {};
      const sourceName = sourceLabel(sourceId, sourceRow);
      title.textContent = `${sourceName} Details`;
      if (range) range.textContent = fmtWindowRange(sourceDataWindowHours);

      const entries = Array.isArray(normalizedHistory?.sources?.[sourceId]?.entries)
        ? normalizedHistory.sources[sourceId].entries
        : [];
      const metrics = computeSourceDataMetrics(entries, sourceDataWindowHours);
      const timelineEvents = Array.isArray(latestOverviewPayload?.timelineBySource?.[sourceId])
        ? [...latestOverviewPayload.timelineBySource[sourceId]]
        : [];
      timelineEvents.sort((a, b) => Date.parse(String(b?.ts || "")) - Date.parse(String(a?.ts || "")));
      const headlineHistory = headlineHistoryFromTimeline(timelineEvents, sourceRow?.item?.url || null);

      if (selectedDetailsTab === "changes") {
        const wrap = document.createElement("div");
        wrap.className = "relatedPanel open";
        if (headlineHistory.original?.title) {
          const first = document.createElement("div");
          first.className = "headlineDiff";
          first.innerHTML = `<div class="headlineDiffMeta"><strong>Original:</strong> ${escapeHtml(fmtTime(headlineHistory.original.ts))}</div><div>${escapeHtml(headlineHistory.original.title)}</div>`;
          wrap.appendChild(first);
        }
        if (headlineHistory.previous?.title) {
          const prev = document.createElement("div");
          prev.className = "headlineDiff";
          prev.innerHTML = `<div class="headlineDiffMeta"><strong>Previous:</strong> ${escapeHtml(fmtTime(headlineHistory.previous.ts))}</div><div>${escapeHtml(headlineHistory.previous.title)}</div>`;
          wrap.appendChild(prev);
        }
        for (const ev of headlineHistory.changes || []) {
          const diff = document.createElement("div");
          diff.className = "headlineDiff";
          const meta = document.createElement("div");
          meta.className = "headlineDiffMeta";
          meta.innerHTML = `<strong>Updated:</strong> ${escapeHtml(fmtTime(ev?.changedAt))}`;
          diff.appendChild(meta);
          appendHeadlineEditMarkup(diff, ev?.fromTitle, ev?.toTitle);
          wrap.appendChild(diff);
        }
        if (!wrap.childElementCount) {
          const empty = document.createElement("div");
          empty.className = "inlineEmpty";
          empty.textContent = "Not enough history yet.";
          host.appendChild(empty);
          return;
        }
        host.appendChild(wrap);
        return;
      }

      if (selectedDetailsTab === "data") {
        const hasData = (metrics.urlChanges + metrics.headlineOnlyChanges) > 0;
        const stats = document.createElement("div");
        stats.className = "statsGrid";
        const statsRows = [
          ["URL changes", String(metrics.urlChanges)],
          ["Headline Changes", String(metrics.headlineOnlyChanges)],
          ["Longest run", fmtDurationMs(metrics.longestRunMs)],
        ];
        for (const [label, value] of statsRows) {
          const card = document.createElement("div");
          card.className = "statCard";
          card.innerHTML = `<div class="statLabel">${escapeHtml(label)}</div><div class="statValue">${escapeHtml(value)}</div>`;
          stats.appendChild(card);
        }
        host.appendChild(stats);
        if (!hasData) {
          const empty = document.createElement("div");
          empty.className = "inlineEmpty";
          empty.textContent = "Not enough history yet.";
          host.appendChild(empty);
          return;
        }
        const c1 = document.createElement("div");
        c1.className = "chartCard";
        c1.innerHTML = `<div class="chartTitle">Changes over time</div>`;
        const canvas1 = document.createElement("canvas");
        canvas1.className = "chartCanvas";
        c1.appendChild(canvas1);
        host.appendChild(c1);
        drawMiniBars(canvas1, metrics.buckets);

        const c2 = document.createElement("div");
        c2.className = "chartCard";
        c2.innerHTML = `<div class="chartTitle">URL vs headline-only split</div>`;
        const canvas2 = document.createElement("canvas");
        canvas2.className = "chartCanvas";
        c2.appendChild(canvas2);
        host.appendChild(c2);
        drawSplitBars(canvas2, metrics);
        return;
      }

      const shots = timelineEvents.filter((ev) => ev?.shot_url);
      if (!shots.length) {
        const empty = document.createElement("div");
        empty.className = "inlineEmpty";
        empty.textContent = "No screenshots available yet.";
        host.appendChild(empty);
        return;
      }
      const topMeta = document.createElement("div");
      topMeta.className = "tiny";
      topMeta.textContent = `What changed: ${timelineKindLabel(shots[0]?.kind || "heartbeat")} · ${fmtTime(shots[0]?.ts)}`;
      host.appendChild(topMeta);

      const frame = document.createElement("div");
      frame.className = "shotFrame";
      const tile = document.createElement("button");
      tile.type = "button";
      tile.className = "shotTile";
      const imgWrap = document.createElement("div");
      imgWrap.style.width = "100%";
      imgWrap.style.aspectRatio = "16 / 9";
      imgWrap.style.borderRadius = "10px";
      imgWrap.style.overflow = "hidden";
      imgWrap.style.background = "#0f1113";
      const img = document.createElement("img");
      img.style.width = "100%";
      img.style.height = "100%";
      img.style.objectFit = "contain";
      imgWrap.appendChild(img);
      tile.appendChild(imgWrap);
      frame.appendChild(tile);
      host.appendChild(frame);

      const controls = document.createElement("div");
      controls.className = "shotRailControls";
      const nav = document.createElement("div");
      nav.className = "snapshotNav";
      const prev = document.createElement("button");
      prev.className = "linkbtn";
      prev.type = "button";
      prev.textContent = "<";
      const next = document.createElement("button");
      next.className = "linkbtn";
      next.type = "button";
      next.textContent = ">";
      const meta = document.createElement("div");
      meta.className = "snapshotStamp";
      const scrubber = document.createElement("input");
      scrubber.type = "range";
      scrubber.className = "shotRailScrubber";
      scrubber.min = "0";
      scrubber.max = String(Math.max(0, shots.length - 1));
      scrubber.step = "1";
      scrubber.value = "0";
      nav.appendChild(prev);
      nav.appendChild(meta);
      nav.appendChild(next);
      controls.appendChild(nav);
      controls.appendChild(scrubber);
      host.appendChild(controls);

      let idx = 0;
      function paint(i){
        idx = Math.max(0, Math.min(shots.length - 1, i));
        const ev = shots[idx];
        meta.textContent = fmtTime(ev?.ts);
        img.src = ev?.shot_url || "";
        prev.disabled = idx <= 0;
        next.disabled = idx >= shots.length - 1;
        scrubber.value = String(idx);
      }
      prev.addEventListener("click", () => paint(idx - 1));
      next.addEventListener("click", () => paint(idx + 1));
      scrubber.addEventListener("input", () => paint(Number(scrubber.value || 0)));
      tile.addEventListener("click", () => ensureShotLightbox().open(shots, idx));
      paint(0);
    }

    // ---- Indicator state: 2h active windows for URL/headline changes ----
    function loadState(){
      try{
        const raw = localStorage.getItem("nb_source_state_v2");
        if (!raw) return {};
        const obj = JSON.parse(raw);
        return obj && typeof obj === "object" ? obj : {};
      } catch {
        return {};
      }
    }

    function saveState(state){
      try{
        localStorage.setItem("nb_source_state_v2", JSON.stringify(state || {}));
      } catch {}
    }

    function deriveFromHistoryEntries(entries, currentUrl, currentTitle, nowMs){
      const out = {
        changeType: null,
        stale2h: false,
        urlFirstSeenAt: 0,
        urlFirstSeenEverAt: 0,
        urlCurrentSinceAt: 0,
        titleFirstSeenAt: 0,
        lastChangeAt: 0,
        lastSeenAt: 0,
        reenteredAt: 0,
      };

      if (!currentUrl || !Array.isArray(entries) || !entries.length) return out;

      const toMs = (x) => {
        const m = Date.parse(String(x || ""));
        return Number.isFinite(m) ? m : 0;
      };
      const entryMs = (e) => toMs(e.firstSeenAt || e.lastSeenAt);
      const ordered = [...entries]
        .filter((e) => e && e.url)
        .map((e) => ({ ...e, __ms: entryMs(e) }))
        .filter((e) => e.__ms > 0)
        .sort((a, b) => a.__ms - b.__ms);
      if (!ordered.length) return out;

      out.lastSeenAt = ordered[ordered.length - 1].__ms;

      const allMatches = ordered.filter((e) => String(e.url) === String(currentUrl));
      if (!allMatches.length) return out;
      out.urlFirstSeenEverAt = entryMs(allMatches[0]);

      const tail = [];
      for (let i = ordered.length - 1; i >= 0; i--) {
        const e = ordered[i];
        if (String(e.url) !== String(currentUrl)) break;
        tail.unshift(e);
      }
      if (!tail.length) return out;

      out.urlFirstSeenAt = entryMs(tail[0]);
      out.urlCurrentSinceAt = out.urlFirstSeenAt;
      if (out.urlFirstSeenEverAt > 0 && out.urlCurrentSinceAt > out.urlFirstSeenEverAt) {
        out.reenteredAt = out.urlCurrentSinceAt;
      }

      const titleTail = [];
      for (let i = tail.length - 1; i >= 0; i--) {
        const e = tail[i];
        if (String(e.title || "") !== String(currentTitle || "")) break;
        titleTail.unshift(e);
      }
      out.titleFirstSeenAt = titleTail.length ? entryMs(titleTail[0]) : out.urlCurrentSinceAt;
      out.lastChangeAt = Math.max(out.urlCurrentSinceAt, out.titleFirstSeenAt);

      if (out.urlCurrentSinceAt > 0 && nowMs - out.urlCurrentSinceAt < STALE_MS) {
        out.changeType = "url";
      } else if (
        out.titleFirstSeenAt > out.urlCurrentSinceAt &&
        out.titleFirstSeenAt > 0 &&
        nowMs - out.titleFirstSeenAt < STALE_MS
      ) {
        out.changeType = "headline";
      }

      out.stale2h = out.lastSeenAt > 0 && nowMs - out.lastSeenAt >= STALE_MS;
      return out;
    }

    function computeIndicators(nextSources, historyObj = null){
      const prevState = loadState();
      const nextState = { ...prevState };
      const indicators = {};
      const now = Date.now();

      for (const [id, src] of Object.entries(nextSources || {})){
        const curUrl = src?.item?.url || null;
        const curTitle = src?.item?.title || null;
        const histEntries = historyObj?.sources?.[id]?.entries || null;
        const histDerived = deriveFromHistoryEntries(histEntries, curUrl, curTitle, now);

        if (Array.isArray(histEntries) && histEntries.length && curUrl) {
          nextState[id] = {
            url: curUrl,
            title: curTitle || null,
            urlFirstSeenAt: histDerived.urlFirstSeenAt || 0,
            urlFirstSeenEverAt: histDerived.urlFirstSeenEverAt || histDerived.urlFirstSeenAt || 0,
            urlCurrentSinceAt: histDerived.urlCurrentSinceAt || histDerived.urlFirstSeenAt || 0,
            titleFirstSeenAt: histDerived.titleFirstSeenAt || 0,
            lastChangeAt: histDerived.lastChangeAt || 0,
            lastSeenAt: histDerived.lastSeenAt || 0,
          };
          indicators[id] = {
            changeType: histDerived.changeType,
            stale2h: histDerived.stale2h,
            firstSeenEverAt: histDerived.urlFirstSeenEverAt || histDerived.urlFirstSeenAt || 0,
            currentSinceAt: histDerived.urlCurrentSinceAt || histDerived.urlFirstSeenAt || 0,
            headlineSinceAt: histDerived.titleFirstSeenAt || 0,
            lastSeenAt: histDerived.lastSeenAt || 0,
            reenteredAt: histDerived.reenteredAt || 0,
          };
          continue;
        }

        const prev = prevState?.[id] || null;
        const prevUrlFirstSeenAt = Number(prev?.urlFirstSeenAt || prev?.lastChangeAt || 0);
        const prevTitleFirstSeenAt = Number(prev?.titleFirstSeenAt || prev?.lastChangeAt || 0);

        let urlFirstSeenAt = prevUrlFirstSeenAt;
        let titleFirstSeenAt = prevTitleFirstSeenAt;

        if (!prev && curUrl) {
          urlFirstSeenAt = now;
          titleFirstSeenAt = now;
        } else if (prev && curUrl) {
          if (String(prev.url || "") !== String(curUrl || "")) {
            urlFirstSeenAt = now;
            titleFirstSeenAt = now;
          } else if (String(prev.title || "") !== String(curTitle || "")) {
            titleFirstSeenAt = now;
          }
        }

        let changeType = null;
        if (curUrl && urlFirstSeenAt > 0 && now - urlFirstSeenAt < STALE_MS) {
          changeType = "url";
        } else if (
          curUrl &&
          titleFirstSeenAt > urlFirstSeenAt &&
          titleFirstSeenAt > 0 &&
          now - titleFirstSeenAt < STALE_MS
        ) {
          changeType = "headline";
        }

        const lastChangeAt = Math.max(urlFirstSeenAt, titleFirstSeenAt, 0);
        const stale2h = !changeType && lastChangeAt > 0 && now - lastChangeAt >= STALE_MS;

        nextState[id] = {
          url: curUrl,
          title: curTitle || null,
          urlFirstSeenAt,
          urlFirstSeenEverAt: urlFirstSeenAt,
          urlCurrentSinceAt: urlFirstSeenAt,
          titleFirstSeenAt,
          lastChangeAt,
          lastSeenAt: now,
        };
        indicators[id] = {
          changeType,
          stale2h,
          firstSeenEverAt: urlFirstSeenAt,
          currentSinceAt: urlFirstSeenAt,
          headlineSinceAt: titleFirstSeenAt,
          lastSeenAt: now,
          reenteredAt: 0,
        };
      }

      return { indicators, nextState };
    }

    function ensureExpectedSources(sources){
      const out = { ...(sources || {}) };
      for (const id of EXPECTED_SOURCE_IDS){
        if (!out[id]) {
          out[id] = {
            ok: false,
            updatedAt: null,
            error: "No data yet",
            item: { title: "—", url: null }
          };
        } else {
          // normalize missing shapes
          if (!out[id].item) out[id].item = { title: "—", url: null };
          if (out[id].item.title == null) out[id].item.title = "—";
        }
      }
      return out;
    }

    function canonicalizeSourcesMap(sources){
      const out = {};
      for (const [rawId, src] of Object.entries(sources || {})) {
        const id = canonicalSourceId(rawId);
        if (!id) continue;
        const row = src || {};
        const item = row.item || {};
        const last = row.last || {};
        const mapped = {
          ...row,
          ok: row.ok !== false,
          updatedAt: row.updatedAt || row.updated_at || last.fetchedAt || null,
          firstSeenAt: row.firstSeenAt || row.first_seen_at || row.since || null,
          secondsInTop: row.secondsInTop ?? row.seconds_in_top ?? null,
          sourceName: row.sourceName || row.source_name || row.name || null,
          changeType: row.changeType || row.change_type || null,
          isStale: Boolean(row.isStale ?? row.is_stale ?? row.stale ?? false),
          lastChangeAt: row.lastChangeAt || row.last_change_at || null,
          item: {
            title: item.title || null,
            url: item.url || null,
            contentType: item.contentType || item.content_type || row.contentType || row.content_type || null,
            breakingLabel: item.breakingLabel || item.breaking_label || row.breakingLabel || row.breaking_label || null,
            breakingHeadline: item.breakingHeadline || item.breaking_headline || row.breakingHeadline || row.breaking_headline || null,
            breakingUrl: item.breakingUrl || item.breaking_url || row.breakingUrl || row.breaking_url || null,
          },
          shot: row.shot || last.shot || null,
        };
        out[id] = mergeSourceRows(out[id], mapped);
      }
      return out;
    }

    function canonicalizeHistoryObj(history){
      const out = { generatedAt: history?.generatedAt || new Date().toISOString(), sources: {} };
      for (const [rawId, payload] of Object.entries(history?.sources || {})) {
        const id = canonicalSourceId(rawId);
        if (!id) continue;
        if (!out.sources[id]) out.sources[id] = { entries: [] };
        const entries = Array.isArray(payload?.entries) ? payload.entries : [];
        out.sources[id].entries.push(...entries);
      }
      return out;
    }

    // ---- Dynamic cards ----
    function pickCardSourceIds(sources){
      // Always render in a stable order with placeholders
      const have = new Set(Object.keys(sources || {}));
      const ordered = [];
      for (const id of EXPECTED_SOURCE_IDS){
        ordered.push(id);
        have.delete(id);
      }
      // append any unexpected sources after
      for (const id of Array.from(have).sort()) ordered.push(id);
      return ordered;
    }

    function tsForSort(sources, id){
      const t = sources?.[id]?.updatedAt || sources?.[id]?.firstSeenAt || null;
      const ms = Date.parse(t || "");
      return Number.isFinite(ms) ? ms : 0;
    }

    function isLiveBlogItem(src){
      if (isVideoItem(src)) return false;
      const contentType = String(src?.item?.contentType || src?.contentType || "").toLowerCase();
      if (contentType === "live") return true;
      const u = String(src?.item?.url || "").toLowerCase();
      const t = String(src?.item?.title || "").toLowerCase();
      return (
        /\/live(\/|$)/.test(u) ||
        /\/live-blog\//.test(u) ||
        /\/live-updates(\/|$)/.test(u) ||
        /\blive blog\b/.test(t)
      );
    }

    function isVideoItem(src){
      const contentType = String(src?.item?.contentType || src?.contentType || "").toLowerCase();
      if (contentType === "video") return true;
      const u = String(src?.item?.url || "").toLowerCase();
      const t = String(src?.item?.title || "").toLowerCase();
      return (
        /\/video(\/|$)/.test(u) ||
        (/\/live(\/|$)/.test(u) && /\babc news live\b/.test(t))
      );
    }

    function changeTsForSort(sources, indicatorsById, id){
      const ind = indicatorsById?.[id] || {};
      const urlMs = Number(ind?.currentSinceAt || 0);
      const headlineMs = Number(ind?.headlineSinceAt || 0);
      const src = sources?.[id] || {};
      const fallbackMs = Date.parse(String(src?.lastChangeAt || src?.updatedAt || src?.firstSeenAt || ""));
      const best = Math.max(
        Number.isFinite(urlMs) ? urlMs : 0,
        Number.isFinite(headlineMs) ? headlineMs : 0,
        Number.isFinite(fallbackMs) ? fallbackMs : 0
      );
      return Number.isFinite(best) ? best : 0;
    }

    function applyCardEntrance(card, id, idx){
      const col = idx % 3;
      const row = Math.floor(idx / 3);
      const x = (col - 1) * 10;
      const y = 18 + (row * 3);
      const r = (col - 1) * 0.55;
      const delay = Math.round((row * 90) + (col * 60));

      card.classList.add("card-enter");
      card.style.setProperty("--enter-x", `${x}px`);
      card.style.setProperty("--enter-y", `${y}px`);
      card.style.setProperty("--enter-r", `${r}deg`);
      card.style.setProperty("--enter-delay", `${delay}ms`);
    }

    function buildCardEl(id, src, indicator, timelineBySource = {}){
      const card = document.createElement("section");
      card.className = "card";
      card.setAttribute("data-source-id", id);

      const head = document.createElement("div");
      head.className = "cardHead";

      const left = document.createElement("div");
      left.className = "srcTitle";

      const meta = document.createElement("div");
      meta.className = "srcMeta";

      const srcName = document.createElement("div");
      srcName.className = "srcName";
      const homeUrl = sourceHomeUrl(id, src);
      if (homeUrl) {
        const srcAnchor = document.createElement("a");
        srcAnchor.className = "srcNameLink";
        srcAnchor.href = homeUrl;
        srcAnchor.target = "_blank";
        srcAnchor.rel = "noopener";
        srcAnchor.textContent = sourceLabel(id, src);
        srcName.appendChild(srcAnchor);
      } else {
        srcName.textContent = sourceLabel(id, src);
      }

      meta.appendChild(srcName);
      left.appendChild(meta);

      const btnCopyLink = document.createElement("button");
      btnCopyLink.className = "copyIconBtn";
      btnCopyLink.type = "button";
      btnCopyLink.textContent = "⧉";
      btnCopyLink.title = "Copy headline link";
      btnCopyLink.setAttribute("aria-label", "Copy headline link");
      btnCopyLink.setAttribute("data-action", "copy-headline");
      btnCopyLink.setAttribute("data-id", id);
      left.appendChild(btnCopyLink);

      const right = document.createElement("div");
      right.className = "rightMeta";

      const time = document.createElement("div");
      time.className = "tiny";
      const updatedAt = src?.updatedAt || null;
      const firstSeenAt = src?.firstSeenAt || src?.since || null;
      const hasHeadlineUpdate = indicator?.changeType === "headline";
      const firstSeenEverAt = indicator?.firstSeenEverAt || firstSeenAt || updatedAt || null;
      const headlineSinceAt = indicator?.headlineSinceAt || updatedAt || null;
      const reenteredAt = indicator?.reenteredAt || 0;

      if (hasHeadlineUpdate && headlineSinceAt) {
        time.textContent = `Updated ${ago(headlineSinceAt)}`;
      } else {
        time.textContent = "";
      }

      const since = document.createElement("div");
      since.className = "tiny";
      if (reenteredAt) {
        since.textContent = `Re-entered ${ago(reenteredAt)}`;
      } else {
        since.textContent = "";
      }

      const firstSeenLine = document.createElement("div");
      firstSeenLine.className = "tiny";
      if (hasHeadlineUpdate && headlineSinceAt) {
        firstSeenLine.textContent = firstSeenEverAt ? `First seen ${ago(firstSeenEverAt)}` : "First seen —";
      } else if (firstSeenEverAt) {
        firstSeenLine.textContent = `First seen ${ago(firstSeenEverAt)}`;
      } else if (src?.secondsInTop !== null && src?.secondsInTop !== undefined) {
        firstSeenLine.textContent = `First seen ${fmtDurationSeconds(src.secondsInTop)} ago`;
      } else {
        firstSeenLine.textContent = "First seen —";
      }

      right.appendChild(time);
      right.appendChild(since);
      right.appendChild(firstSeenLine);

      head.appendChild(left);
      head.appendChild(right);

      const body = document.createElement("div");
      body.className = "cardBody";

      const wrap = document.createElement("div");
      wrap.className = "headlineWrap";

      if (src?.item?.breakingLabel) {
        const breakingTag = document.createElement("div");
        breakingTag.className = "breakingNewsTag";
        breakingTag.textContent = src.item.breakingLabel;
        wrap.appendChild(breakingTag);
      }

      if (isVideoItem(src)) {
        const videoTag = document.createElement("div");
        videoTag.className = "videoTag";
        videoTag.textContent = "Video";
        wrap.appendChild(videoTag);
      }

      if (isLiveBlogItem(src)) {
        const liveTag = document.createElement("div");
        liveTag.className = "liveBlogTag";
        liveTag.textContent = "Live Blog";
        wrap.appendChild(liveTag);
      }

      const h2 = document.createElement("h2");
      h2.className = "headline";
      const a = document.createElement("a");
      a.setAttribute("data-role", "headline-link");
      a.setAttribute("data-id", id);
      a.href = src?.item?.url || "#";
      a.target = "_blank";
      a.rel = "noopener";
      a.textContent = src?.item?.title || "—";
      h2.appendChild(a);

      const changeRow = document.createElement("div");
      changeRow.className = "changeRow";
      const dot = document.createElement("span");
      const changeType = String(indicator?.changeType || "").toLowerCase();
      const stale2h = Boolean(src?.isStale) || Boolean(indicator?.stale2h);
      dot.className = `changeDot ${changeType === "url" ? "url" : changeType === "headline" ? "headline" : stale2h ? "stale" : "none"}`;
      changeRow.appendChild(dot);

      const actionsRow = document.createElement("div");
      actionsRow.className = "cardActions";
      const detailsBtn = document.createElement("button");
      detailsBtn.type = "button";
      detailsBtn.className = "linkbtn";
      detailsBtn.textContent = "Details";
      detailsBtn.setAttribute("data-action", "open-source-data");
      detailsBtn.setAttribute("data-id", id);
      actionsRow.appendChild(changeRow);
      actionsRow.appendChild(detailsBtn);

      const err = document.createElement("div");
      err.className = "tiny";
      err.textContent = src?.error ? String(src.error) : "";

      wrap.appendChild(h2);
      wrap.appendChild(actionsRow);
      wrap.appendChild(err);

      body.appendChild(wrap);

      card.appendChild(head);
      card.appendChild(body);

      return card;
    }

    function sortedOverviewIds(sources, indicatorsById){
      const ids = pickCardSourceIds(sources);
      // Group by change type first: URL change, then headline change, then unchanged.
      function changePriority(id){
        const type = String(indicatorsById?.[id]?.changeType || "").toLowerCase();
        if (type === "url") return 0;
        if (type === "headline") return 1;
        return 2;
      }
      ids.sort((a,b) => {
        const pa = changePriority(a);
        const pb = changePriority(b);
        if (pa !== pb) return pa - pb;

        const ca = changeTsForSort(sources, indicatorsById, a);
        const cb = changeTsForSort(sources, indicatorsById, b);
        if (cb !== ca) return cb - ca;

        const ta = tsForSort(sources, a);
        const tb = tsForSort(sources, b);
        if (tb !== ta) return tb - ta;
        return String(a).localeCompare(String(b));
      });
      return ids;
    }

    function renderCards(sources, indicatorsById, timelineBySource = {}){
      const grid = $("cards-grid");
      if (!grid) return;
      grid.innerHTML = "";
      const ids = sortedOverviewIds(sources, indicatorsById);
      const hasContent = ids.some((id) => {
        const src = sources?.[id] || {};
        const title = String(src?.item?.title || "").trim();
        const url = String(src?.item?.url || "").trim();
        return (title && title !== "—") || url;
      });

      for (const id of ids){
        const src = sources?.[id] || {};
        const ind = indicatorsById?.[id] || { changeType: null, stale2h: false };
        const card = buildCardEl(id, src, ind, timelineBySource);
        applyCardEntrance(card, id, grid.children.length);
        grid.appendChild(card);
      }

      if (!hasContent) {
        const empty = document.createElement("div");
        empty.className = "emptyState";
        empty.style.gridColumn = "1 / -1";
        empty.textContent = "No data yet. Refreshing will repopulate cards when sources are available.";
        grid.appendChild(empty);
      }

      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          for (const card of grid.querySelectorAll(".card.card-enter")) {
            card.classList.add("card-settle");
          }
        });
      });
    }

    function normalizeForCluster(value){
      return String(value || "")
        .toLowerCase()
        .replace(/https?:\/\//g, " ")
        .replace(/[^a-z0-9\s]/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    }

    function slugify(value){
      const s = normalizeForCluster(value).replace(/\s+/g, "-");
      return s || `cluster-${Math.random().toString(36).slice(2, 8)}`;
    }

    function titleCaseShortLabel(phrase){
      const tokens = normalizeForCluster(phrase).split(" ").filter(Boolean);
      const sliced = tokens.slice(0, 2);
      if (!sliced.length) return "Topic";
      return sliced.map((tok) => tok.charAt(0).toUpperCase() + tok.slice(1)).join(" ");
    }

    function clusterSanitize(obj, fallbackLabel = "Topic"){
      const label = String(obj?.label || fallbackLabel).trim() || fallbackLabel;
      const includeAny = Array.isArray(obj?.includeAny) ? obj.includeAny.map((x) => String(x || "").trim()).filter(Boolean) : [];
      const includeAll = Array.isArray(obj?.includeAll) ? obj.includeAll.map((x) => String(x || "").trim()).filter(Boolean) : [];
      const exclude = Array.isArray(obj?.exclude) ? obj.exclude.map((x) => String(x || "").trim()).filter(Boolean) : [];
      return {
        id: String(obj?.id || slugify(label)),
        label,
        priority: Number.isFinite(Number(obj?.priority)) ? Number(obj.priority) : 50,
        includeAny,
        includeAll,
        exclude,
        createdAt: obj?.createdAt || new Date().toISOString(),
        pinned: Boolean(obj?.pinned),
      };
    }

    function loadJSONStorage(key, fallback){
      try{
        const raw = localStorage.getItem(key);
        if (!raw) return fallback;
        const parsed = JSON.parse(raw);
        return parsed ?? fallback;
      } catch {
        return fallback;
      }
    }

    function saveJSONStorage(key, value){
      try { localStorage.setItem(key, JSON.stringify(value)); } catch {}
    }

    function loadClusterCardOrder(){
      const raw = loadJSONStorage(CLUSTER_CARD_ORDER_KEY, {});
      if (!raw || typeof raw !== "object") return {};
      return raw;
    }

    function saveClusterCardOrder(){
      saveJSONStorage(CLUSTER_CARD_ORDER_KEY, clusterCardOrder || {});
    }

    function loadPinnedClusters(){
      const stored = loadJSONStorage(CLUSTER_PINNED_KEY, null);
      if (Array.isArray(stored)) {
        return stored.map((row) => clusterSanitize({ ...row, pinned: true }, row?.label || "Topic"));
      }
      return DEFAULT_CLUSTERS.map((c) => clusterSanitize({ ...c, pinned: true }, c.label));
    }

    function savePinnedClusters(clusters){
      const keep = (clusters || []).map((c) => clusterSanitize({ ...c, pinned: true }, c?.label || "Topic"));
      saveJSONStorage(CLUSTER_PINNED_KEY, keep);
    }

    function loadActiveClusters(pinned){
      const stored = loadJSONStorage(CLUSTER_ACTIVE_KEY, null);
      if (Array.isArray(stored)) {
        return stored.map((row) => clusterSanitize(row, row?.label || "Topic"));
      }
      return (pinned || []).map((c) => clusterSanitize(c, c.label));
    }

    function saveActiveClusters(clusters){
      const keep = (clusters || []).map((c) => clusterSanitize(c, c?.label || "Topic"));
      saveJSONStorage(CLUSTER_ACTIVE_KEY, keep);
    }

    function loadDismissedSuggestions(){
      const stored = loadJSONStorage(CLUSTER_DISMISSED_KEY, []);
      if (!Array.isArray(stored)) return new Set();
      return new Set(stored.map((x) => normalizeForCluster(x)).filter(Boolean));
    }

    function saveDismissedSuggestions(setObj){
      saveJSONStorage(CLUSTER_DISMISSED_KEY, Array.from(setObj || []));
    }

    let pinnedClusters = loadPinnedClusters();
    let activeClusters = loadActiveClusters(pinnedClusters);
    let dismissedSuggestions = loadDismissedSuggestions();
    clusterCardOrder = loadClusterCardOrder();

    function clusterSort(a, b){
      const pa = Number(a?.priority || 0);
      const pb = Number(b?.priority || 0);
      if (pb !== pa) return pb - pa;
      return String(a?.label || "").localeCompare(String(b?.label || ""));
    }

    function overviewItemsFromSources(sources){
      const out = [];
      for (const [sourceId, src] of Object.entries(sources || {})) {
        out.push({
          sourceId,
          sourceName: sourceLabel(sourceId, src),
          title: String(src?.item?.title || ""),
          url: String(src?.item?.url || ""),
        });
      }
      return out;
    }

    function textTokens(value){
      return normalizeForCluster(value).split(" ").filter(Boolean);
    }

    const CLUSTER_STOPWORDS = new Set([
      "the","a","an","and","or","for","with","from","into","over","under","amid","after","before","during",
      "says","warns","calls","live","latest","update","updates","new","news","today","why","how","what","when",
      "who","his","her","their","our","your","this","that","these","those","will","could","should","about","into",
      "video","photos","photo","story","stories","analysis","report","reports","breaking","just","more","than"
    ]);

    function phraseLooksUseful(phrase){
      const norm = normalizeForCluster(phrase);
      if (norm.length < 8) return false;
      const toks = norm.split(" ").filter(Boolean);
      if (!toks.length) return false;
      const meaningful = toks.filter((t) => t.length > 2 && !CLUSTER_STOPWORDS.has(t));
      return meaningful.length >= 2;
    }

    function phraseTokensForOverlap(phrase){
      return normalizeForCluster(phrase)
        .split(" ")
        .filter(Boolean)
        .filter((t) => !CLUSTER_STOPWORDS.has(t))
        .map((t) => {
          if (t.length > 5 && t.endsWith("ing")) return t.slice(0, -3);
          if (t.length > 4 && t.endsWith("er")) return t.slice(0, -2);
          if (t.length > 4 && t.endsWith("ed")) return t.slice(0, -2);
          if (t.length > 4 && t.endsWith("es")) return t.slice(0, -2);
          if (t.length > 3 && t.endsWith("s")) return t.slice(0, -1);
          return t;
        });
    }

    function phrasesOverlap(a, b){
      const na = normalizeForCluster(a);
      const nb = normalizeForCluster(b);
      if (!na || !nb) return false;
      if (na.includes(nb) || nb.includes(na)) return true;
      const ta = new Set(phraseTokensForOverlap(na));
      const tb = new Set(phraseTokensForOverlap(nb));
      if (!ta.size || !tb.size) return false;
      let common = 0;
      for (const tok of ta) {
        if (tb.has(tok)) common += 1;
      }
      const minLen = Math.min(ta.size, tb.size);
      return minLen > 0 && (common / minLen) >= 0.6;
    }

    function phrasesShareCoreToken(a, b){
      const ta = new Set(phraseTokensForOverlap(a).filter((t) => t.length >= 5));
      const tb = new Set(phraseTokensForOverlap(b).filter((t) => t.length >= 5));
      if (!ta.size || !tb.size) return false;
      for (const tok of ta) {
        if (tb.has(tok)) return true;
      }
      return false;
    }

    function phrasesConflict(a, b){
      return phrasesOverlap(a, b) || phrasesShareCoreToken(a, b);
    }

    function extractCapitalizedPhrases(title){
      const out = [];
      const matches = String(title || "").match(/(?:\b(?:[A-Z][a-z]+|[A-Z]{2,})\b(?:\s+|$)){2,3}/g) || [];
      for (const m of matches) {
        const trimmed = String(m || "").trim();
        if (trimmed) out.push(trimmed);
      }
      return out;
    }

    function extractNgrams(tokens, minN = 2, maxN = 3){
      const out = [];
      for (let n = minN; n <= maxN; n += 1) {
        for (let i = 0; i + n <= tokens.length; i += 1) {
          const slice = tokens.slice(i, i + n);
          if (slice.some((t) => CLUSTER_STOPWORDS.has(t))) continue;
          out.push(slice.join(" "));
        }
      }
      return out;
    }

    function extractUrlPhrases(url){
      try{
        const u = new URL(url);
        const toks = u.pathname
          .split("/")
          .flatMap((seg) => seg.split(/[-_]+/))
          .map((t) => normalizeForCluster(t))
          .filter((t) => t && t.length > 2 && !CLUSTER_STOPWORDS.has(t));
        return extractNgrams(toks, 1, 2);
      } catch {
        return [];
      }
    }

    function phraseCoveredByClusters(phrase, clusters){
      const p = normalizeForCluster(phrase);
      for (const c of (clusters || [])) {
        for (const inc of (c.includeAny || [])) {
          const n = normalizeForCluster(inc);
          if (!n) continue;
          if (p.includes(n) || n.includes(p) || phrasesConflict(p, n)) return true;
        }
      }
      return false;
    }

    function buildClusterSuggestions(items, clusters){
      const byPhrase = new Map();
      for (const item of (items || [])) {
        const sourceId = String(item?.sourceId || "");
        const title = String(item?.title || "");
        const url = String(item?.url || "");
        const titleTokens = textTokens(title);
        const filteredTitleTokens = titleTokens.filter((t) => t.length > 2 && !CLUSTER_STOPWORDS.has(t));
        const candidates = [
          ...extractNgrams(filteredTitleTokens, 2, 3),
          ...extractCapitalizedPhrases(title),
          ...extractUrlPhrases(url),
        ];
        const itemKey = normalizeForCluster(`${sourceId} ${url || title}`);
        const uniqueCandidates = new Set(candidates.map((x) => normalizeForCluster(x)).filter(Boolean));
        for (const phrase of uniqueCandidates) {
          if (!phraseLooksUseful(phrase)) continue;
          if (!byPhrase.has(phrase)) byPhrase.set(phrase, { phrase, itemKeys: new Set(), sources: new Set() });
          const row = byPhrase.get(phrase);
          if (itemKey) row.itemKeys.add(itemKey);
          if (sourceId) row.sources.add(sourceId);
        }
      }

      const scored = [];
      for (const row of byPhrase.values()) {
        const articleCount = row.itemKeys.size;
        const publisherDiversity = row.sources.size;
        const score = (publisherDiversity * 3) + articleCount;
        if (!(publisherDiversity >= 2 || articleCount >= 2)) continue;
        if (phraseCoveredByClusters(row.phrase, clusters)) continue;
        if (dismissedSuggestions.has(normalizeForCluster(row.phrase))) continue;
        scored.push({
          phrase: row.phrase,
          count: articleCount,
          publisherDiversity,
          score,
        });
      }
      scored.sort((a, b) => (b.score - a.score) || (b.publisherDiversity - a.publisherDiversity) || (b.count - a.count) || a.phrase.localeCompare(b.phrase));
      const out = [];
      for (const cand of scored) {
        if (out.some((k) => phrasesConflict(k.phrase, cand.phrase))) continue;
        out.push(cand);
        if (out.length >= 10) break;
      }
      return out;
    }

    function createClusterFromPhrase(phrase){
      const label = titleCaseShortLabel(phrase);
      return clusterSanitize({
        id: slugify(label),
        label,
        priority: 50,
        includeAny: [String(phrase || "").trim()],
        includeAll: [],
        exclude: [],
        createdAt: new Date().toISOString(),
        pinned: false,
      }, label);
    }

    function phraseTokenSet(phrase){
      return new Set(
        normalizeForCluster(phrase)
          .split(" ")
          .filter(Boolean)
          .filter((t) => !CLUSTER_STOPWORDS.has(t))
          .map((t) => {
            if (t.length > 5 && t.endsWith("ing")) return t.slice(0, -3);
            if (t.length > 4 && t.endsWith("er")) return t.slice(0, -2);
            if (t.length > 4 && t.endsWith("ed")) return t.slice(0, -2);
            if (t.length > 4 && t.endsWith("es")) return t.slice(0, -2);
            if (t.length > 3 && t.endsWith("s")) return t.slice(0, -1);
            return t;
          })
          .filter((t) => t.length >= 4),
      );
    }

    function phraseTokenOverlapScore(phrase, titleNorm, urlNorm){
      const phraseTokens = phraseTokenSet(phrase);
      if (!phraseTokens.size) return 0;
      const titleTokens = phraseTokenSet(titleNorm);
      const urlTokens = phraseTokenSet(urlNorm);
      let titleHits = 0;
      let urlHits = 0;
      for (const tok of phraseTokens) {
        if (titleTokens.has(tok)) titleHits += 1;
        if (urlTokens.has(tok)) urlHits += 1;
      }
      if (!titleHits && !urlHits) return 0;
      let score = 0;
      if (titleHits > 0) score += 2 + (titleHits * 1.5);
      if (urlHits > 0) score += 1 + (urlHits * 0.75);
      if (titleHits >= 2) score += 1.5;
      return score;
    }

    function matchCluster(item, cluster){
      const titleNorm = normalizeForCluster(item?.title || "");
      const urlNorm = normalizeForCluster(item?.url || "");
      const combined = `${titleNorm} ${urlNorm}`.trim();
      let score = 0;

      for (const phraseRaw of (cluster?.includeAny || [])) {
        const phrase = normalizeForCluster(phraseRaw);
        if (!phrase) continue;
        if (titleNorm.includes(phrase)) score += 4;
        if (urlNorm.includes(phrase)) score += 2;
        if (!titleNorm.includes(phrase) && !urlNorm.includes(phrase)) {
          score += phraseTokenOverlapScore(phrase, titleNorm, urlNorm);
        }
      }

      const includeAll = (cluster?.includeAll || []).map((x) => normalizeForCluster(x)).filter(Boolean);
      if (includeAll.length && includeAll.every((p) => combined.includes(p))) score += 3;

      for (const phraseRaw of (cluster?.exclude || [])) {
        const phrase = normalizeForCluster(phraseRaw);
        if (phrase && combined.includes(phrase)) score -= 10;
      }

      return { score, match: score >= 4 };
    }

    function autoActivateClustersForCoverage(sources){
      const ids = sortedOverviewIds(sources || {}, latestOverviewPayload?.indicators || {});
      if (ids.length <= 3) return false;

      const countOther = () => {
        const sorted = [...activeClusters].sort(clusterSort);
        let other = 0;
        for (const id of ids) {
          const src = sources?.[id] || {};
          const item = { sourceId: id, title: src?.item?.title || "", url: src?.item?.url || "" };
          const clusterId = assignItemToCluster(item, sorted);
          if (clusterId === "other") other += 1;
        }
        return other;
      };

      let otherCount = countOther();
      if (otherCount <= 3) return false;

      const suggestions = buildClusterSuggestions(overviewItemsFromSources(sources), [...activeClusters]);
      let changed = false;
      for (const suggestion of suggestions) {
        if (otherCount <= 3) break;
        const cluster = createClusterFromPhrase(suggestion.phrase);
        const exists = activeClusters.some((c) =>
          c.id === cluster.id ||
          phrasesConflict(c.label, cluster.label) ||
          (c.includeAny || []).some((p) => (cluster.includeAny || []).some((q) => phrasesConflict(p, q)))
        );
        if (exists) continue;
        activeClusters.push(cluster);
        changed = true;
        otherCount = countOther();
      }
      if (changed) saveActiveClusters(activeClusters);
      return changed;
    }

    function assignItemToCluster(item, clusters){
      let best = null;
      for (const cluster of [...(clusters || [])].sort(clusterSort)) {
        const result = matchCluster(item, cluster);
        if (!result.match) continue;
        if (!best || result.score > best.score || (result.score === best.score && Number(cluster.priority || 0) > Number(best.cluster.priority || 0))) {
          best = { cluster, score: result.score };
        }
      }
      return best ? best.cluster.id : "other";
    }

    function upsertActiveCluster(cluster){
      const c = clusterSanitize(cluster, cluster?.label || "Topic");
      const overlapIdx = activeClusters.findIndex((x) =>
        x.id === c.id ||
        phrasesConflict(x.label, c.label) ||
        (x.includeAny || []).some((p) => (c.includeAny || []).some((q) => phrasesConflict(p, q)))
      );
      if (overlapIdx >= 0) {
        const merged = activeClusters[overlapIdx];
        const includeAny = new Set([...(merged.includeAny || []), ...(c.includeAny || []), c.label]);
        merged.includeAny = Array.from(includeAny).filter(Boolean);
        if (Number(c.priority || 0) > Number(merged.priority || 0)) {
          merged.priority = c.priority;
          merged.label = c.label;
        }
        activeClusters[overlapIdx] = clusterSanitize(merged, merged.label);
      } else {
        activeClusters.push(c);
      }
      saveActiveClusters(activeClusters);
    }

    function consolidateActiveClusters(){
      if (!Array.isArray(activeClusters) || activeClusters.length < 2) return false;
      const sorted = [...activeClusters].sort(clusterSort);
      const out = [];
      let changed = false;
      for (const c0 of sorted) {
        const c = clusterSanitize(c0, c0?.label || "Topic");
        const idx = out.findIndex((x) =>
          phrasesConflict(x.label, c.label) ||
          (x.includeAny || []).some((p) => (c.includeAny || []).some((q) => phrasesConflict(p, q)))
        );
        if (idx < 0) {
          out.push(c);
          continue;
        }
        changed = true;
        const base = out[idx];
        const includeAny = new Set([...(base.includeAny || []), ...(c.includeAny || []), c.label, base.label]);
        base.includeAny = Array.from(includeAny).filter(Boolean);
        if (Number(c.priority || 0) > Number(base.priority || 0)) {
          base.priority = c.priority;
          base.label = c.label;
        }
        out[idx] = clusterSanitize(base, base.label);
      }
      if (changed) {
        activeClusters = out;
        saveActiveClusters(activeClusters);
      }
      return changed;
    }

    function removeActiveCluster(clusterId){
      const removed = activeClusters.find((c) => c.id === clusterId) || null;
      activeClusters = activeClusters.filter((c) => c.id !== clusterId);
      if (removed) {
        for (const phrase of (removed.includeAny || [])) {
          dismissedSuggestions.delete(normalizeForCluster(phrase));
        }
        saveDismissedSuggestions(dismissedSuggestions);
      }
      saveActiveClusters(activeClusters);
    }

    function setPinned(cluster, pinned){
      const c = clusterSanitize({ ...cluster, pinned }, cluster?.label || "Topic");
      if (pinned) {
        const idx = pinnedClusters.findIndex((x) => x.id === c.id);
        if (idx >= 0) pinnedClusters[idx] = c;
        else pinnedClusters.push(c);
      } else {
        pinnedClusters = pinnedClusters.filter((x) => x.id !== c.id);
      }
      savePinnedClusters(pinnedClusters);
    }

    function renderClusterChips(items){
      const activeHost = $("cluster-active");
      const suggHost = $("cluster-suggestions");
      if (activeHost) activeHost.innerHTML = "";
      if (suggHost) suggHost.innerHTML = "";

      const activeSorted = [...activeClusters].sort(clusterSort);
      if (activeHost) {
        for (const cluster of activeSorted) {
          const chip = document.createElement("div");
          chip.className = "chip";
          const lbl = document.createElement("button");
          lbl.type = "button";
          lbl.className = "chipLabel";
          lbl.textContent = cluster.label;
          lbl.title = (cluster.includeAny || []).join(", ");

          const pin = document.createElement("button");
          pin.type = "button";
          pin.className = "chipAction";
          pin.textContent = pinnedClusters.some((x) => x.id === cluster.id) ? "•" : "o";
          pin.title = pinnedClusters.some((x) => x.id === cluster.id) ? "Unpin" : "Pin";
          pin.addEventListener("click", () => {
            const isPinned = pinnedClusters.some((x) => x.id === cluster.id);
            setPinned(cluster, !isPinned);
            renderStoryClusters(latestOverviewPayload.sources, latestOverviewPayload.indicators, latestOverviewPayload.timelineBySource);
          });

          const remove = document.createElement("button");
          remove.type = "button";
          remove.className = "chipAction";
          remove.textContent = "×";
          remove.setAttribute("aria-label", `Remove ${cluster.label}`);
          remove.addEventListener("click", () => {
            removeActiveCluster(cluster.id);
            renderStoryClusters(latestOverviewPayload.sources, latestOverviewPayload.indicators, latestOverviewPayload.timelineBySource);
          });

          chip.appendChild(lbl);
          chip.appendChild(pin);
          chip.appendChild(remove);
          activeHost.appendChild(chip);
        }
      }

      const suggestions = buildClusterSuggestions(items, [...activeClusters]);
      if (suggHost) {
        for (const suggestion of suggestions) {
          const chip = document.createElement("div");
          chip.className = "chip";
          const lbl = document.createElement("button");
          lbl.type = "button";
          lbl.className = "chipLabel";
          lbl.textContent = `${titleCaseShortLabel(suggestion.phrase)} (${suggestion.count})`;
          lbl.addEventListener("click", () => {
            const cluster = createClusterFromPhrase(suggestion.phrase);
            upsertActiveCluster(cluster);
            dismissedSuggestions.delete(normalizeForCluster(suggestion.phrase));
            saveDismissedSuggestions(dismissedSuggestions);
            renderStoryClusters(latestOverviewPayload.sources, latestOverviewPayload.indicators, latestOverviewPayload.timelineBySource);
          });

          const add = document.createElement("button");
          add.type = "button";
          add.className = "chipAction";
          add.textContent = "×";
          add.title = "Dismiss suggestion";
          add.addEventListener("click", () => {
            dismissedSuggestions.add(normalizeForCluster(suggestion.phrase));
            saveDismissedSuggestions(dismissedSuggestions);
            renderStoryClusters(latestOverviewPayload.sources, latestOverviewPayload.indicators, latestOverviewPayload.timelineBySource);
          });

          chip.appendChild(lbl);
          chip.appendChild(add);
          suggHost.appendChild(chip);
        }
      }
    }

    function renderClusteredOverview(sources, indicatorsById, timelineBySource = {}){
      const groupsHost = $("cluster-groups");
      if (!groupsHost) return;
      groupsHost.innerHTML = "";
      if (!sources || !Object.keys(sources).length) return;

      function applySavedOrder(clusterId, idsInGroup){
        const saved = Array.isArray(clusterCardOrder?.[clusterId]) ? clusterCardOrder[clusterId] : [];
        if (!saved.length) return [...idsInGroup];
        const keep = new Set(idsInGroup);
        const ordered = saved.filter((id) => keep.has(id));
        for (const id of idsInGroup) {
          if (!ordered.includes(id)) ordered.push(id);
        }
        return ordered;
      }

      function persistGridOrder(clusterId, gridEl){
        const order = [...gridEl.querySelectorAll(".card[data-source-id]")]
          .map((el) => String(el.getAttribute("data-source-id") || ""))
          .filter(Boolean);
        clusterCardOrder[clusterId] = order;
        saveClusterCardOrder();
      }

      function afterElementByY(container, y){
        const candidates = [...container.querySelectorAll(".card:not(.dragging)")];
        let best = { offset: Number.NEGATIVE_INFINITY, el: null };
        for (const child of candidates) {
          const rect = child.getBoundingClientRect();
          const offset = y - rect.top - (rect.height / 2);
          if (offset < 0 && offset > best.offset) best = { offset, el: child };
        }
        return best.el;
      }

      const ids = sortedOverviewIds(sources, indicatorsById);

      const activeSorted = [...activeClusters].sort(clusterSort);
      const grouped = new Map();
      for (const cluster of activeSorted) grouped.set(cluster.id, []);
      grouped.set("other", []);

      for (const id of ids) {
        const src = sources?.[id] || {};
        const item = { sourceId: id, title: src?.item?.title || "", url: src?.item?.url || "" };
        const clusterId = assignItemToCluster(item, activeSorted);
        if (!grouped.has(clusterId)) grouped.set(clusterId, []);
        grouped.get(clusterId).push(id);
      }

      const order = [...activeSorted.map((c) => c.id), "other"];
      for (const clusterId of order) {
        const idsInGroup = applySavedOrder(clusterId, grouped.get(clusterId) || []);
        if (!idsInGroup.length) continue;

        const section = document.createElement("section");
        section.className = "clusterGroup";
        const head = document.createElement("div");
        head.className = "clusterHeader";
        const h1 = document.createElement("h1");
        const label = clusterId === "other"
          ? "Other"
          : (activeSorted.find((c) => c.id === clusterId)?.label || "Other");
        h1.textContent = label;
        const count = document.createElement("span");
        count.className = "tiny";
        count.textContent = `(${idsInGroup.length})`;
        head.appendChild(h1);
        head.appendChild(count);

        const groupGrid = document.createElement("div");
        groupGrid.className = "grid";
        for (const id of idsInGroup) {
          const src = sources?.[id] || {};
          const ind = indicatorsById?.[id] || { changeType: null, stale2h: false };
          const card = buildCardEl(id, src, ind, timelineBySource);
          card.draggable = true;
          card.addEventListener("dragstart", (e) => {
            card.classList.add("dragging");
            e.dataTransfer?.setData("text/plain", id);
            if (e.dataTransfer) e.dataTransfer.effectAllowed = "move";
          });
          card.addEventListener("dragend", () => {
            card.classList.remove("dragging");
            persistGridOrder(clusterId, groupGrid);
          });
          applyCardEntrance(card, id, groupGrid.children.length);
          groupGrid.appendChild(card);
        }

        groupGrid.addEventListener("dragover", (e) => {
          e.preventDefault();
          const dragging = groupGrid.querySelector(".card.dragging");
          if (!dragging) return;
          const after = afterElementByY(groupGrid, e.clientY);
          if (!after) groupGrid.appendChild(dragging);
          else groupGrid.insertBefore(dragging, after);
        });
        groupGrid.addEventListener("drop", (e) => {
          e.preventDefault();
          persistGridOrder(clusterId, groupGrid);
        });

        section.appendChild(head);
        section.appendChild(groupGrid);
        groupsHost.appendChild(section);
      }

      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          for (const card of groupsHost.querySelectorAll(".card.card-enter")) {
            card.classList.add("card-settle");
          }
        });
      });
    }

    function renderOverview(sources, indicatorsById, timelineBySource = {}){
      latestOverviewPayload = { sources, indicators: indicatorsById, timelineBySource };
      renderCards(sources, indicatorsById, timelineBySource);
    }

    function renderStoryClusters(sources, indicatorsById, timelineBySource = {}){
      latestOverviewPayload = { sources, indicators: indicatorsById, timelineBySource };
      consolidateActiveClusters();
      autoActivateClustersForCoverage(sources);
      const items = overviewItemsFromSources(sources);
      renderClusterChips(items);
      renderClusteredOverview(sources, indicatorsById, timelineBySource);
    }

    // Overview card click -> open source details on screenshots tab.
    document.addEventListener("click", (e) => {
      const card = e.target && e.target.closest ? e.target.closest(".card[data-source-id]") : null;
      if (!card) return;
      if (card.classList.contains("dragging")) return;
      if (e.target && e.target.closest && e.target.closest("a, button, input, select, label")) return;
      const id = card.getAttribute("data-source-id");
      if (!id) return;
      setDetailsTab("shots");
      setSourceDataOpen(true, id);
    });

    // Copy/details handlers (URL not displayed)
    document.addEventListener("click", async (e) => {
      const btn = e.target && e.target.closest ? e.target.closest("button[data-action]") : null;
      if (!btn) return;

      const action = btn.getAttribute("data-action");
      const id = btn.getAttribute("data-id");
      if (!action || !id) return;

      const link = document.querySelector(`a[data-role="headline-link"][data-id="${CSS.escape(id)}"]`);
      const href = link && link.href && link.href !== "#" ? link.href : "";

      if (action === "copy-headline") {
        if (!href) return showToast("Nothing to copy");
        try { await copyText(href); showToast("Copied"); } catch { showToast("Copy failed"); }
        return;
      }

      if (action === "open-source-data") {
        setDetailsTab("shots");
        setSourceDataOpen(true, id);
      }
    });

    async function loadPublishedCache() {
      return await fetchJSON(`${CACHE_URL}?ts=${Date.now()}`);
    }

    async function loadPublishedTimeline(hours = 12) {
      try {
        const payload = await fetchJSON(`${TIMELINE_URL}?ts=${Date.now()}`);
        const events = Array.isArray(payload?.events) ? payload.events : [];
        const cutoffMs = Date.now() - (Number(hours) * 60 * 60 * 1000);
        return events.filter((ev) => {
          const t = Date.parse(String(ev?.ts || ""));
          return Number.isFinite(t) ? t >= cutoffMs : false;
        });
      } catch {
        return [];
      }
    }

    function deepDiveRunsForWindow() {
      const runs = Array.isArray(deepDiveState.historyRuns) ? deepDiveState.historyRuns : [];
      const cutoffMs = Date.now() - (Number(deepDiveState.windowHours || DEEP_DIVE_DEFAULT_HOURS) * 60 * 60 * 1000);
      return runs
        .filter((run) => {
          const ms = Date.parse(String(run?.observedAt || ""));
          return Number.isFinite(ms) && ms >= cutoffMs;
        })
        .sort((a, b) => Date.parse(String(a?.observedAt || "")) - Date.parse(String(b?.observedAt || "")));
    }

    function deepDiveDurationLabel(fromTs, toTs){
      const from = Date.parse(String(fromTs || ""));
      const to = Date.parse(String(toTs || ""));
      if (!Number.isFinite(from) || !Number.isFinite(to) || to < from) return "—";
      return fmtDurationSeconds(Math.floor((to - from) / 1000));
    }

    function escapeHtml(v){
      return String(v || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/\"/g, "&quot;");
    }

    function headlineDiffHtml(prevTitle, nextTitle){
      const a = String(prevTitle || "");
      const b = String(nextTitle || "");
      if (!a && !b) return "—";
      if (!a || !b || a === b) return escapeHtml(b || a);

      let start = 0;
      const minLen = Math.min(a.length, b.length);
      while (start < minLen && a[start] === b[start]) start += 1;

      let endA = a.length - 1;
      let endB = b.length - 1;
      while (endA >= start && endB >= start && a[endA] === b[endB]) {
        endA -= 1;
        endB -= 1;
      }

      const prefix = a.slice(0, start);
      const removed = a.slice(start, endA + 1);
      const added = b.slice(start, endB + 1);
      const suffix = b.slice(endB + 1);

      let html = "";
      if (prefix) html += escapeHtml(prefix);
      if (removed) html += `<span class="diffDel">${escapeHtml(removed)}</span>`;
      if (added) html += `<span class="diffAdd">${escapeHtml(added)}</span>`;
      if (suffix) html += escapeHtml(suffix);
      return html;
    }

    function isMinorHeadlineEdit(prevTitle, nextTitle){
      const a = String(prevTitle || "").trim();
      const b = String(nextTitle || "").trim();
      if (!a || !b || a === b) return true;

      const maxLen = Math.max(a.length, b.length);
      const minLen = Math.min(a.length, b.length);
      if (!maxLen) return true;

      let start = 0;
      while (start < minLen && a[start] === b[start]) start += 1;

      let endA = a.length - 1;
      let endB = b.length - 1;
      while (endA >= start && endB >= start && a[endA] === b[endB]) {
        endA -= 1;
        endB -= 1;
      }

      const changed = Math.max(0, (endA - start + 1)) + Math.max(0, (endB - start + 1));
      return changed <= Math.max(14, Math.round(maxLen * 0.28));
    }

    function appendHeadlineEditMarkup(host, prevTitle, nextTitle){
      const majorEdit = !isMinorHeadlineEdit(prevTitle, nextTitle);
      if (majorEdit) {
        const newest = document.createElement("div");
        newest.className = "headlineNew";
        newest.textContent = String(nextTitle || "—");
        host.appendChild(newest);
      }

      const line = document.createElement("div");
      line.innerHTML = headlineDiffHtml(prevTitle, nextTitle);
      host.appendChild(line);
    }

    function headlineHistoryFromTimeline(events, currentUrl = null){
      const rows = [...(events || [])]
        .filter((ev) => ev && ev.ts && ev.title && ev.url)
        .sort((a, b) => Date.parse(String(a.ts || "")) - Date.parse(String(b.ts || "")));

      if (!rows.length) return { original: null, previous: null, changes: [] };

      const latest = rows[rows.length - 1];
      const activeUrl = String(currentUrl || latest?.url || "");
      if (!activeUrl) return { original: null, previous: null, changes: [] };

      // Current URL streak (same story URL currently in No. 1 spot).
      const streak = [];
      for (let i = rows.length - 1; i >= 0; i--) {
        const ev = rows[i];
        if (String(ev?.url || "") !== activeUrl) break;
        streak.unshift(ev);
      }
      if (!streak.length) return { original: null, previous: null, changes: [] };

      const streakStartIdx = rows.length - streak.length;
      const prevEv = streakStartIdx > 0 ? rows[streakStartIdx - 1] : null;
      const previous = prevEv
        ? { title: String(prevEv.title || "").trim(), ts: prevEv.ts, url: prevEv.url || null }
        : null;
      const original = { title: String(streak[0].title || "").trim(), ts: streak[0].ts, url: activeUrl };

      const out = [];
      let prevTitle = null;
      for (const ev of streak) {
        const title = String(ev.title || "").trim();
        if (!title) continue;
        if (prevTitle === null) {
          prevTitle = title;
          continue;
        }
        if (title !== prevTitle) {
          out.push({
            fromTitle: prevTitle,
            toTitle: title,
            changedAt: ev.ts,
          });
          prevTitle = title;
        }
      }

      return {
        original,
        previous,
        changes: out.sort((a, b) => Date.parse(String(b?.changedAt || "")) - Date.parse(String(a?.changedAt || ""))),
      };
    }

    function deepDiveMovement(item, prevRun){
      const prevItems = Array.isArray(prevRun?.items) ? prevRun.items : [];
      const prev = prevItems.find((x) => String(x?.fingerprint || "") === String(item?.fingerprint || ""));
      if (!prev) return { label: "NEW", delta: null };
      const p = Number(prev.rank);
      const c = Number(item?.rank);
      if (!Number.isFinite(p) || !Number.isFinite(c)) return { label: "NEW", delta: null };
      if (p === c) return { label: `#${p}`, delta: 0 };
      if (p > c) return { label: `↑ #${p}`, delta: p - c };
      return { label: `↓ #${p}`, delta: c - p };
    }

    function isBreakingBannerTop10Item(item){
      const title = String(item?.title || "").trim();
      return /^breaking(\b|\d)/i.test(title);
    }

    function deepDiveTop10Since(runs, selectedIdx, fingerprint){
      let firstIdx = selectedIdx;
      for (let i = selectedIdx; i >= 0; i--) {
        const has = (runs[i]?.items || []).some((it) => String(it?.fingerprint || "") === String(fingerprint || ""));
        if (!has) break;
        firstIdx = i;
      }
      return runs[firstIdx]?.observedAt || null;
    }

    function deepDiveHeadlineChanges(runs, selectedIdx, row) {
      const fp = String(row?.fingerprint || "");
      if (!fp) return [];

      const events = [];
      let currentTitle = null;
      let currentTitleFirstSeenAt = null;

      for (let i = 0; i <= selectedIdx; i++) {
        const it = (runs[i]?.items || []).find((x) => String(x?.fingerprint || "") === fp);
        if (!it) continue;
        const title = String(it?.title || "");
        if (!title) continue;

        if (currentTitle === null) {
          currentTitle = title;
          currentTitleFirstSeenAt = runs[i]?.observedAt || null;
          continue;
        }

        if (title !== currentTitle) {
          events.push({
            fromTitle: currentTitle,
            toTitle: title,
            firstSeenAt: runs[i]?.observedAt || null,
            changedAt: runs[i]?.observedAt || null,
          });
          currentTitle = title;
          currentTitleFirstSeenAt = runs[i]?.observedAt || null;
        }
      }

      if (!events.length) return [];

      // Reverse chronological (latest first)
      return events.sort((a, b) => Date.parse(String(b?.changedAt || "")) - Date.parse(String(a?.changedAt || "")));
    }

    function deepDiveNo1Since(runs, selectedIdx, fingerprint){
      let lastNo1Idx = -1;
      for (let i = selectedIdx; i >= 0; i--) {
        const row = (runs[i]?.items || []).find((it) => String(it?.fingerprint || "") === String(fingerprint || ""));
        if (row && Number(row.rank) === 1) {
          lastNo1Idx = i;
          break;
        }
      }
      if (lastNo1Idx < 0) return null;

      let firstIdx = lastNo1Idx;
      for (let i = lastNo1Idx; i >= 0; i--) {
        const row = (runs[i]?.items || []).find((it) => String(it?.fingerprint || "") === String(fingerprint || ""));
        if (!row || Number(row.rank) !== 1) break;
        firstIdx = i;
      }
      return runs[firstIdx]?.observedAt || null;
    }

    function deepDiveRelatedSince(runs, selectedIdx, url){
      let firstIdx = selectedIdx;
      for (let i = selectedIdx; i >= 0; i--) {
        const topRow = (runs[i]?.items || [])[0] || null;
        const rel = Array.isArray(topRow?.related_links) ? topRow.related_links : [];
        const has = rel.some((it) => String(it?.url || "") === String(url || ""));
        if (!has) break;
        firstIdx = i;
      }
      return runs[firstIdx]?.observedAt || null;
    }

    function setView(which, persist = true) {
      const valid = new Set(["overview", "data", "playxplay", "labs"]);
      activeView = valid.has(which) ? which : "overview";

      const overview = $("view-overview");
      const playxplay = $("view-playxplay");
      const labs = $("view-labs");
      const tabOverview = $("tab-overview");
      const tabData = $("tab-data");
      const tabPlayXPlay = $("tab-playxplay");
      const tabLabs = $("tab-labs");

      const showOverview = activeView === "overview";
      const showData = activeView === "data";
      const showPlayXPlay = activeView === "playxplay";
      const showLabs = activeView === "labs";

      if (overview) overview.style.display = showOverview ? "" : "none";
      if (playxplay) playxplay.style.display = showPlayXPlay ? "" : "none";
      if (labs) labs.style.display = showLabs ? "" : "none";

      if (tabOverview) {
        tabOverview.classList.toggle("active", showOverview);
        tabOverview.setAttribute("aria-selected", showOverview ? "true" : "false");
      }
      if (tabData) {
        tabData.classList.toggle("active", showData);
        tabData.setAttribute("aria-selected", showData ? "true" : "false");
      }
      if (tabPlayXPlay) {
        tabPlayXPlay.classList.toggle("active", showPlayXPlay);
        tabPlayXPlay.setAttribute("aria-selected", showPlayXPlay ? "true" : "false");
      }
      if (tabLabs) {
        tabLabs.classList.toggle("active", showLabs);
        tabLabs.setAttribute("aria-selected", showLabs ? "true" : "false");
      }

      if (persist) {
        try { localStorage.setItem(VIEW_STORAGE_KEY, activeView); } catch {}
      }

      if (showLabs) {
        renderStoryClusters(latestOverviewPayload.sources, latestOverviewPayload.indicators, latestOverviewPayload.timelineBySource);
      }
      if (showData) {
        setDataOpen(true);
      } else {
        setDataOpen(false);
      }
    }

    function renderDeepDive() {
      const latest = deepDiveState.latest || {};
      const runs = deepDiveRunsForWindow();
      if (!deepDiveState.selectedObservedAt && runs.length) {
        deepDiveState.selectedObservedAt = runs[runs.length - 1]?.observedAt || null;
      }
      const foundIdx = runs.findIndex((r) => String(r?.observedAt || "") === String(deepDiveState.selectedObservedAt || ""));
      const selectedIdx = foundIdx >= 0 ? foundIdx : Math.max(0, runs.length - 1);
      const selectedRun = runs[selectedIdx] || latest || {};
      const prevRun = selectedIdx > 0 ? runs[selectedIdx - 1] : null;
      const topItems = Array.isArray(selectedRun?.items)
        ? [...selectedRun.items]
          .filter((row) => !isBreakingBannerTop10Item(row))
          .sort((a, b) => Number(a.rank) - Number(b.rank))
        : [];

      const rail = $("deep-run-rail");
      if (rail) {
        rail.innerHTML = "";
        const stamp = document.createElement("div");
        stamp.className = "snapshotStamp";
        stamp.textContent = selectedRun?.observedAt ? fmtTime(selectedRun.observedAt) : "No snapshots";

        const stampNav = document.createElement("div");
        stampNav.className = "snapshotNav";
        const prevSnap = document.createElement("button");
        prevSnap.className = "linkbtn";
        prevSnap.type = "button";
        prevSnap.textContent = "<";
        const nextSnap = document.createElement("button");
        nextSnap.className = "linkbtn";
        nextSnap.type = "button";
        nextSnap.textContent = ">";
        stampNav.appendChild(prevSnap);
        stampNav.appendChild(stamp);
        stampNav.appendChild(nextSnap);

        const scrubber = document.createElement("input");
        scrubber.className = "shotRailScrubber";
        scrubber.type = "range";
        scrubber.min = "0";
        scrubber.max = String(Math.max(0, runs.length - 1));
        scrubber.step = "1";
        scrubber.value = String(runs.length ? (runs.length - 1 - selectedIdx) : 0); // 0=newest, max=oldest
        scrubber.disabled = runs.length <= 1;
        let pendingReverseIdx = Number(scrubber.value || 0);

        function runFromReverseIdx(reverseIdx) {
          if (!runs.length) return;
          const idx = Math.max(0, Math.min(runs.length - 1, Number(reverseIdx || 0)));
          const nextIdx = (runs.length - 1) - idx;
          return runs[nextIdx] || null;
        }

        function previewScrubSelection() {
          const next = runFromReverseIdx(pendingReverseIdx);
          if (!next) return;
          stamp.textContent = fmtTime(next?.observedAt);
        }

        function commitScrubSelection() {
          const next = runFromReverseIdx(pendingReverseIdx);
          if (!next) return;
          if (String(next?.observedAt || "") === String(deepDiveState.selectedObservedAt || "")) return;
          deepDiveState.selectedObservedAt = next?.observedAt || null;
          renderDeepDive();
        }

        function stepScrubber(delta) {
          if (scrubber.disabled) return;
          const min = Number(scrubber.min || 0);
          const max = Number(scrubber.max || 0);
          const current = Number(scrubber.value || 0);
          const next = Math.max(min, Math.min(max, current + delta));
          if (next === current) return;
          scrubber.value = String(next);
          pendingReverseIdx = next;
          previewScrubSelection();
          commitScrubSelection();
        }

        scrubber.addEventListener("input", () => {
          pendingReverseIdx = Number(scrubber.value || 0);
          previewScrubSelection();
        });
        scrubber.addEventListener("change", commitScrubSelection);
        scrubber.addEventListener("mouseup", commitScrubSelection);
        scrubber.addEventListener("touchend", commitScrubSelection, { passive: true });
        scrubber.addEventListener("wheel", (ev) => {
          if (scrubber.disabled) return;
          ev.preventDefault();
          const dir = ev.deltaY > 0 ? 1 : -1;
          stepScrubber(dir);
        }, { passive: false });

        prevSnap.disabled = runs.length <= 1;
        nextSnap.disabled = runs.length <= 1;
        // Left (<): more recent. Right (>): older / back in time.
        prevSnap.addEventListener("click", () => stepScrubber(-1));
        nextSnap.addEventListener("click", () => stepScrubber(1));

        rail.appendChild(stampNav);
        rail.appendChild(scrubber);
      }

      const latestTime = $("deep-latest-time");
      if (latestTime) latestTime.textContent = `Observed: ${selectedRun?.observedAt ? fmtTime(selectedRun.observedAt) : "—"}`;

      const err = $("deep-latest-error");
      if (err) err.textContent = selectedRun?.ok === false ? String(selectedRun?.error || "Top 10 scrape incomplete") : "";

      const topList = $("deep-top10-list");
      if (topList) {
        topList.innerHTML = "";
        for (const row of topItems) {
          const li = document.createElement("li");
          li.className = "top10Row";

          const rank = document.createElement("div");
          rank.className = "top10Rank";
          rank.textContent = `${Number(row?.rank) || "?"}.`;

          const body = document.createElement("div");
          body.className = "deepEventBody";
          const a = document.createElement("a");
          a.className = "top10Link";
          a.href = row?.url || "#";
          a.target = "_blank";
          a.rel = "noopener";
          a.textContent = row?.title || "—";
          body.appendChild(a);

          const meta = document.createElement("div");
          meta.className = "top10Meta";

          const move = deepDiveMovement(row, prevRun);
          const top10Since = deepDiveTop10Since(runs, selectedIdx, row?.fingerprint);
          const no1Since = deepDiveNo1Since(runs, selectedIdx, row?.fingerprint);

          function metric(label, value, klass, showLabel = true) {
            const wrap = document.createElement("div");
            wrap.className = "metric";
            const lbl = document.createElement("span");
            lbl.className = "statLabel";
            lbl.textContent = label;
            const chip = document.createElement("span");
            chip.className = `statBtn ${klass || ""}`.trim();
            chip.textContent = value || "—";
            if (showLabel) wrap.appendChild(lbl);
            wrap.appendChild(chip);
            return { wrap, chip };
          }

          const showLabels = Number(row?.rank) === 1;
          const prevValue = move.label || "—";
          const no1Value = deepDiveDurationLabel(no1Since, selectedRun?.observedAt);
          const top10Value = deepDiveDurationLabel(top10Since, selectedRun?.observedAt);

          const mPrev = metric("Previously", prevValue, `isPrev ${String(move.label || "").startsWith("↓") ? "down" : ""}`, showLabels);
          const mNo1 = metric("No. 1", no1Value, "isNo1", showLabels);
          const mTop10 = metric("Top 10", top10Value, "isTop10", showLabels);

          if (Number(row?.rank) === 1) {
            meta.appendChild(mNo1.wrap); // Always show for #1
            if (top10Value !== "—") meta.appendChild(mTop10.wrap);
            if (prevValue !== "NEW") meta.appendChild(mPrev.wrap); // New #1 has no "Previously"
          } else {
            meta.appendChild(mPrev.wrap);
            if (no1Value !== "—") meta.appendChild(mNo1.wrap);
            if (top10Value !== "—") meta.appendChild(mTop10.wrap);
          }

          if (move.delta && Number.isFinite(move.delta)) {
            const intensity = Math.min(0.52, 0.16 + (move.delta * 0.04));
            const dirDown = String(move.label || "").startsWith("↓");
            mPrev.chip.style.background = dirDown
              ? `linear-gradient(90deg, rgba(255,255,255,.92), rgba(200,108,0,${intensity}))`
              : `linear-gradient(90deg, rgba(200,108,0,${intensity}), rgba(255,255,255,.9))`;
          }

          body.appendChild(meta);

          const headlineChanges = deepDiveHeadlineChanges(runs, selectedIdx, row);
          const related = Number(row?.rank) === 1 && Array.isArray(row?.related_links) ? row.related_links : [];
          const hasDetails = Boolean(headlineChanges.length);
          if (hasDetails) {
            const wrap = document.createElement("div");
            wrap.className = "relatedWrap";

            const toggle = document.createElement("button");
            toggle.type = "button";
            toggle.className = "relatedToggle";
            toggle.textContent = Number(row?.rank) === 1 && related.length ? `Details (${related.length} context)` : "Details";

            const panel = document.createElement("div");
            panel.className = "relatedPanel";

            for (const ev of headlineChanges) {
              const diff = document.createElement("div");
              diff.className = "headlineDiff";
              const metaLine = document.createElement("div");
              metaLine.className = "headlineDiffMeta";
              metaLine.innerHTML = `<strong>Updated:</strong> ${escapeHtml(fmtTime(ev?.changedAt))}`;
              diff.appendChild(metaLine);
              appendHeadlineEditMarkup(diff, ev?.fromTitle, ev?.toTitle);
              panel.appendChild(diff);
            }

            // For #1, list content/context links after headline changes.
            if (related.length) {
              const list = document.createElement("ul");
              list.className = "relatedList";
              for (const rel of related) {
                const item = document.createElement("li");
                item.className = "relatedItem";

                const link = document.createElement("a");
                link.className = "relatedLink";
                link.href = rel?.url || "#";
                link.target = "_blank";
                link.rel = "noopener";
                link.textContent = rel?.title || rel?.url || "Related link";

                const since = deepDiveRelatedSince(runs, selectedIdx, rel?.url);
                const chip = document.createElement("span");
                chip.className = "statBtn isTop10";
                chip.textContent = deepDiveDurationLabel(since, selectedRun?.observedAt);

                item.appendChild(link);
                if (chip.textContent !== "—") item.appendChild(chip);
                list.appendChild(item);
              }
              panel.appendChild(list);
            }

            toggle.addEventListener("click", () => panel.classList.toggle("open"));
            wrap.appendChild(toggle);
            wrap.appendChild(panel);
            body.appendChild(wrap);
          }

          li.appendChild(rank);
          li.appendChild(body);
          topList.appendChild(li);
        }
        if (!topItems.length) {
          const li = document.createElement("li");
          li.className = "top10Row";
          li.textContent = "No Top 10 snapshot available yet.";
          topList.appendChild(li);
        }
      }
    }

    async function loadDeepDiveData() {
      let latest = null;
      let historyRuns = [];

      try {
        latest = await fetchJSON(`${TOP10_ABC_LATEST_URL}?ts=${Date.now()}`);
      } catch {}

      try {
        const payload = await fetchJSON(`${TOP10_ABC_HISTORY_URL}?ts=${Date.now()}`);
        historyRuns = Array.isArray(payload?.runs) ? payload.runs : [];
      } catch {
        historyRuns = [];
      }

      deepDiveState.latest = latest || { ok: false, observedAt: null, items: [], error: "Timeline data unavailable" };
      deepDiveState.historyRuns = historyRuns;
      if (!deepDiveState.selectedObservedAt && deepDiveState.latest?.observedAt) {
        deepDiveState.selectedObservedAt = deepDiveState.latest.observedAt;
      }
      renderDeepDive();
    }

    async function loadCardTimelineBySource(hours = 12, sourcesData = null) {
      function derivePublicShotUrl(objectPath){
        if (!objectPath) return null;
        const base = String(_supabaseCfg?.url || "").replace(/\/+$/, "");
        if (!base) return null;
        return `${base}/storage/v1/object/public/${SUPABASE_SCREENSHOT_BUCKET}/${objectPath}`;
      }

      function buildFromCacheSources(srcMap){
        const out = {};
        for (const [rawId, rawSrc] of Object.entries(srcMap || {})) {
          const id = canonicalSourceId(rawId);
          if (!id) continue;
          const src = rawSrc || {};
          const shot = src.shot || src.last?.shot || null;
          const objectPath = shot?.object_path || shot?.objectPath || null;
          const shotUrl = shot?.shot_url || shot?.shotUrl || derivePublicShotUrl(objectPath);
          if (!shotUrl) continue;
          if (!out[id]) out[id] = [];
          out[id].push({
            ts: src.updatedAt || src.updated_at || src.last?.fetchedAt || null,
            source_id: id,
            kind: src.changeType || src.change_type || "heartbeat",
            title: src?.item?.title || null,
            url: src?.item?.url || null,
            shot_url: shotUrl,
          });
        }
        return out;
      }

      if (isGitHubPages) {
        const published = await loadPublishedTimeline(hours);
        if (published.length) {
          const out = {};
          for (const ev of published) {
            const id = canonicalSourceId(ev?.source_id || "");
            if (!id) continue;
            if (!out[id]) out[id] = [];
            out[id].push(ev);
          }
          return out;
        }
        if (!_supabaseCfg) _supabaseCfg = await loadSupabaseConfig();
        return buildFromCacheSources(sourcesData || {});
      }

      try {
        const resp = await fetchJSON(`/api/timeline?hours=${encodeURIComponent(String(hours))}`);
        const events = Array.isArray(resp?.events) ? resp.events : [];
        const out = {};
        for (const ev of events) {
          const id = canonicalSourceId(ev?.source_id || "");
          if (!id) continue;
          if (!out[id]) out[id] = [];
          out[id].push(ev);
        }
        return out;
      } catch {
        return buildFromCacheSources(sourcesData || {});
      }
    }

    function timelineKindLabel(kind){
      if (kind === "new_url") return "URL changed";
      if (kind === "new_headline") return "Headline changed";
      return "Heartbeat";
    }

    async function reload() {
      const btnReload = $("btn-reload");
      if (btnReload) btnReload.disabled = true;
      isRefreshing = true;
      renderStatusLine();
      setPlayXPlayStatus("Loading updates...");

      try {
        let data = null;
        let history = null;
        let timelineBySource = {};

        try{
          const sb = await loadFromSupabase();
          if (sb?.cacheLike) {
            data = sb.cacheLike;
            history = sb.history;
          }
        } catch (e){
          console.warn("Supabase load failed", e);
        }

        if (!data) {
          data = await loadPublishedCache();
        }

        // Ensure we always have the full set, so cards don't disappear
        const sources = ensureExpectedSources(canonicalizeSourcesMap(data?.sources || {}));
        const latestSourceTs = Math.max(
          0,
          ...Object.values(sources || {}).map((src) => {
            const ms = Date.parse(String(src?.updatedAt || src?.lastChangeAt || ""));
            return Number.isFinite(ms) ? ms : 0;
          })
        );
        const generatedMs = Date.parse(String(data?.generatedAt || ""));
        lastSuccessfulUpdateTs = latestSourceTs || (Number.isFinite(generatedMs) ? generatedMs : 0);
        lastRefreshError = null;

        if (!history) {
          history = await fetchJSON(`./data/history.json?ts=${Date.now()}`).catch(() => null);
        }
        const normalizedHistory = canonicalizeHistoryObj(history || {});
        timelineBySource = await loadCardTimelineBySource(12, sources);

        const { indicators, nextState } = computeIndicators(sources, normalizedHistory);
        latestDrawerPayload = { normalizedHistory, sources, indicators };
        renderData(normalizedHistory, indicators, sources, selectedWindowHours);
        renderHistory(normalizedHistory, sources, indicators, {
          hostId: "playxplay-history",
          useWindow: false,
          recentLimit: PLAY_X_PLAY_RECENT_LIMIT,
        });
        renderOverview(sources, indicators, timelineBySource);
        renderStoryClusters(sources, indicators, timelineBySource);
        if (nextState) saveState(nextState);
        setPlayXPlayStatus(`Updated ${fmtTime(new Date().toISOString())}`);
        if ($("drawer-source-data")?.classList.contains("open") && selectedSourceDataId) {
          renderSourceDataPanel(selectedSourceDataId);
        }
        await loadDeepDiveData();

      } catch (e) {
        console.error("Refresh error:", e);
        lastRefreshError = summarizeError(e);
        showToast(`Refresh failed: ${lastRefreshError}`);
        const hasExisting = Object.keys(latestOverviewPayload?.sources || {}).length > 0;
        if (!hasExisting) {
          const placeholderSources = ensureExpectedSources({});
          const placeholderIndicators = {};
          const normalizedHistory = { generatedAt: null, sources: {} };
          latestDrawerPayload = { normalizedHistory, sources: placeholderSources, indicators: placeholderIndicators };
          renderData(normalizedHistory, placeholderIndicators, placeholderSources, selectedWindowHours);
          renderHistory(normalizedHistory, placeholderSources, placeholderIndicators, {
            hostId: "playxplay-history",
            useWindow: false,
            recentLimit: PLAY_X_PLAY_RECENT_LIMIT,
          });
          renderOverview(placeholderSources, placeholderIndicators, {});
          renderStoryClusters(placeholderSources, placeholderIndicators, {});
        }
        setPlayXPlayStatus("Refresh failed. Showing last successful Play x Play data when available.");
        await loadDeepDiveData().catch(() => {});
      } finally {
        isRefreshing = false;
        renderStatusLine();
        if (btnReload) btnReload.disabled = false;
      }
    }

    async function runScrapeLocal() {
      const btnRun = $("btn-run");
      if (btnRun) btnRun.disabled = true;

      try {
        await fetchJSON(`/api/refresh`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({}),
        });

        await reload();
        showToast("Scrape complete");
      } catch (e) {
        console.error("Run scrape error:", e);
        showToast("Scrape failed");
      } finally {
        if (btnRun) btnRun.disabled = false;
      }
    }

    $("btn-reload")?.addEventListener("click", reload);
    $("btn-menu")?.addEventListener("click", () => setMenuOpen(true));
    $("btn-menu-close")?.addEventListener("click", () => setMenuOpen(false));
    $("legend-toggle")?.addEventListener("click", () => {
      const panel = $("legend-more");
      const btn = $("legend-toggle");
      if (!panel || !btn) return;
      const open = panel.classList.toggle("open");
      btn.setAttribute("aria-expanded", open ? "true" : "false");
    });
    $("tab-overview")?.addEventListener("click", () => setView("overview"));
    $("tab-data")?.addEventListener("click", () => setView("data"));
    $("tab-playxplay")?.addEventListener("click", () => setView("playxplay"));
    $("tab-labs")?.addEventListener("click", () => setView("labs"));
    $("details-tab-changes")?.addEventListener("click", () => setDetailsTab("changes"));
    $("details-tab-data")?.addEventListener("click", () => setDetailsTab("data"));
    $("details-tab-shots")?.addEventListener("click", () => setDetailsTab("shots"));
    $("deep-window")?.addEventListener("change", (e) => {
      deepDiveState.windowHours = Number(e.target.value || DEEP_DIVE_DEFAULT_HOURS);
      deepDiveState.selectedObservedAt = null;
      renderDeepDive();
    });

    $("btn-history-close")?.addEventListener("click", () => setHistoryOpen(false));
    $("btn-data-close")?.addEventListener("click", () => setDataOpen(false));
    $("btn-source-data-close")?.addEventListener("click", () => setSourceDataOpen(false));
    $("source-data-window")?.addEventListener("change", (e) => {
      sourceDataWindowHours = parseHoursSpec(e.target.value);
      if (selectedSourceDataId) renderSourceDataPanel(selectedSourceDataId);
    });
    $("history-window")?.addEventListener("change", (e) => setSelectedWindowHours(e.target.value));
    $("data-window")?.addEventListener("change", (e) => setSelectedWindowHours(e.target.value));
    $("drawer-overlay")?.addEventListener("click", () => closeAllDrawers());
    $("menu-go-overview")?.addEventListener("click", () => {
      setMenuOpen(false);
      setView("overview");
    });
    $("menu-go-data")?.addEventListener("click", () => {
      setMenuOpen(false);
      setView("data");
    });
    $("menu-go-playxplay")?.addEventListener("click", () => {
      setMenuOpen(false);
      setView("playxplay");
    });
    $("menu-go-labs")?.addEventListener("click", () => {
      setMenuOpen(false);
      setView("labs");
    });

    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        if (_shotLightbox) _shotLightbox.close();
        closeAllDrawers();
      }
    });

    if (isLocal && !isGitHubPages) {
      const btnRun = $("btn-run");
      if (btnRun) {
        btnRun.style.display = "inline-block";
        btnRun.addEventListener("click", runScrapeLocal);
      }
    }

    let initialView = "overview";
    try {
      const savedView = String(localStorage.getItem(VIEW_STORAGE_KEY) || "").toLowerCase();
      if (savedView === "overview" || savedView === "data" || savedView === "playxplay" || savedView === "labs") {
        initialView = savedView;
      }
    } catch {}
    setView(initialView, false);
    setSelectedWindowHours(HISTORY_WINDOW_DEFAULT_HOURS);
    sourceDataWindowHours = HISTORY_WINDOW_DEFAULT_HOURS;
    setDetailsTab("changes");
    const sourceDataWindow = $("source-data-window");
    if (sourceDataWindow) sourceDataWindow.value = String(sourceDataWindowHours);
    const deepWindow = $("deep-window");
    if (deepWindow) deepWindow.value = String(DEEP_DIVE_DEFAULT_HOURS);
    renderStatusLine();
    reload();
  </script>
</body>
</html>
